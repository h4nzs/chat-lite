diff --git a/server/src/routes/conversations.ts b/server/src/routes/conversations.ts
index 49f28e42..366c5b96 100644
--- a/server/src/routes/conversations.ts
+++ b/server/src/routes/conversations.ts
@@ -5,6 +5,7 @@ import { requireAuth } from '../middleware/auth.js'
 import { getIo } from '../socket.js'
 import { rotateAndDistributeSessionKeys } from '../utils/sessionKeys.js'
 import { ApiError } from '../utils/errors.js'
+import { redisClient } from '../lib/redis.js'
 
 const router: Router = Router()
 router.use(requireAuth)
@@ -83,6 +84,14 @@ router.post('/', async (req, res, next) => {
       return res.status(400).json({ error: 'userIds must be an array.' })
     }
 
+    // SANDBOX CHECK
+    const user = await prisma.user.findUnique({ where: { id: creatorId }, select: { isVerified: true } });
+    const isVerified = user?.isVerified ?? false;
+
+    if (!isVerified && isGroup) {
+        throw new ApiError(403, 'SANDBOX_GROUP_RESTRICTION: Unverified users cannot create groups.');
+    }
+
     if (userIds.length > MAX_GROUP_MEMBERS) {
       return res.status(400).json({ error: `Group cannot have more than ${MAX_GROUP_MEMBERS} members.` })
     }
@@ -103,6 +112,18 @@ router.post('/', async (req, res, next) => {
       })
 
       if (existingConversation) return res.status(200).json(existingConversation)
+        
+      // SANDBOX DM LIMIT (Only for NEW conversations)
+      if (!isVerified) {
+          const today = new Date().toISOString().split('T')[0];
+          const key = `sandbox:newchat:${creatorId}:${today}`;
+          const count = await redisClient.incr(key);
+          if (count === 1) await redisClient.expire(key, 86400); // 24h
+          
+          if (count > 3) {
+              throw new ApiError(429, 'SANDBOX_NEW_CHAT_LIMIT: Max 3 new conversations per day.');
+          }
+      }
     }
 
     const allUserIds = Array.from(new Set([...userIds, creatorId]))
diff --git a/server/src/routes/users.ts b/server/src/routes/users.ts
index 6e1577f4..4c73a23e 100644
--- a/server/src/routes/users.ts
+++ b/server/src/routes/users.ts
@@ -19,6 +19,11 @@ router.get('/search', async (req, res, next) => {
     }
 
     // q adalah usernameHash yang dikirim client
+    
+    // SANDBOX CHECK
+    const user = await prisma.user.findUnique({ where: { id: req.user!.id }, select: { isVerified: true } });
+    const limit = user?.isVerified ? 20 : 3;
+
     const users = await prisma.user.findMany({
       where: {
         AND: [
@@ -32,7 +37,7 @@ router.get('/search', async (req, res, next) => {
         isVerified: true,
         publicKey: true
       },
-      take: 5
+      take: limit
     })
 
     res.json(users)
diff --git a/server/src/socket.ts b/server/src/socket.ts
index 979dd7f7..45f8bf69 100644
--- a/server/src/socket.ts
+++ b/server/src/socket.ts
@@ -316,7 +316,19 @@ export function registerSocket(httpServer: HttpServer) {
     });
 
     socket.on('message:send', async (message: MessageSendPayload, callback: (res: { ok: boolean, msg?: Message, error?: string }) => void) => {
-      // 1. Rate Limit
+      // 1. Sandbox Rate Limit (Strict)
+      const user = await prisma.user.findUnique({ where: { id: userId }, select: { isVerified: true } });
+      if (!user?.isVerified) {
+          const key = `sandbox:msg:${userId}`;
+          const count = await redisClient.incr(key);
+          if (count === 1) await redisClient.expire(key, 60);
+          
+          if (count > 5) {
+              return callback?.({ ok: false, error: "SANDBOX_LIMIT_REACHED: Max 5 messages per minute. Verify account to unlock." });
+          }
+      }
+
+      // 2. Standard Rate Limit
       if (!await checkRateLimit(userId, 'message', 15, 60)) { // 15 messages / minute
          return callback?.({ ok: false, error: "Rate limit exceeded. Slow down." });
       }
diff --git a/web/src/pages/Register.tsx b/web/src/pages/Register.tsx
index 16e58492..d433065f 100644
--- a/web/src/pages/Register.tsx
+++ b/web/src/pages/Register.tsx
@@ -7,16 +7,26 @@ import { Turnstile } from '@marsidev/react-turnstile';
 import toast from "react-hot-toast";
 import { hashUsername, generateProfileKey, encryptProfile } from "@lib/crypto-worker-proxy";
 import { saveProfileKey } from "@lib/keychainDb";
+import { startRegistration, platformAuthenticatorIsAvailable } from '@simplewebauthn/browser';
+import { api } from "@lib/api";
+import { FiShield, FiSkipForward } from "react-icons/fi";
+import { IoFingerPrint } from "react-icons/io5";
 
 export default function Register() {
   const [error, setError] = useState("");
-  const [step, setStep] = useState<'form' | 'recovery'>('form');
+  const [step, setStep] = useState<'form' | 'biometric' | 'recovery'>('form');
   const [recoveryPhrase, setRecoveryPhrase] = useState('');
   const [turnstileToken, setTurnstileToken] = useState<string>('');
+  const [isBiometricsSupported, setIsBiometricsSupported] = useState(false);
+  const [isVerifyingBio, setIsVerifyingBio] = useState(false);
 
   const navigate = useNavigate();
   const { registerAndGeneratePhrase } = useAuthStore();
 
+  useEffect(() => {
+    platformAuthenticatorIsAvailable().then(setIsBiometricsSupported);
+  }, []);
+
   async function handleRegister(data: { name?: string, d?: string, b?: string }) {
     const { name, d: username, b: password } = data;
     setError("");
@@ -24,24 +34,15 @@ export default function Register() {
     // --- Validation Logic ---
     if (!name) { throw new Error("Name is required"); }
     if (name.length > 80) { throw new Error("Name must be less than 80 characters"); }
-    
-    // Username constraints (min 3 chars)
     if (!username || username.length < 3) { throw new Error("Username must be at least 3 characters"); }
     const usernameRegex = /^[a-zA-Z0-9_]+$/;
     if (!usernameRegex.test(username)) { throw new Error("Username can only contain letters, numbers, and underscores"); }
-    
     if (!password) { throw new Error("Password is required"); }
     if (password.length < 8) { throw new Error("Password must be at least 8 characters"); }
     // --- End Validation ---
 
-    // Validasi Turnstile
-    // if (!turnstileToken) { throw new Error("Please complete the CAPTCHA."); }
-
     try {
-      // CLIENT-SIDE BLIND INDEXING
       const usernameHash = await hashUsername(username);
-
-      // PROFILE ENCRYPTION
       const profileKeyB64 = await generateProfileKey();
       const profileJson = JSON.stringify({ name, description: "", avatarUrl: "" });
       const encryptedProfile = await encryptProfile(profileJson, profileKeyB64);
@@ -53,39 +54,124 @@ export default function Register() {
         turnstileToken 
       });
 
-      // Save own ProfileKey to IDB
       await saveProfileKey(result.userId, profileKeyB64);
-
       setRecoveryPhrase(result.phrase);
-      setStep('recovery'); // Success! Show phrase.
-      toast.success("Account created successfully!");
+      
+      // Move to Biometric step instead of Recovery directly
+      setStep('biometric');
+      toast.success("Identity initialized. Setup security.");
       
     } catch (err: any) {
       setError(err.message || "Registration failed");
     }
   }
 
+  const handleBiometricRegister = async () => {
+    setIsVerifyingBio(true);
+    try {
+      // 1. Get Options
+      const options = await api<any>("/api/auth/webauthn/register/options");
+      
+      // 2. Browser Prompt
+      const attResp = await startRegistration(options);
+      
+      // 3. Verify on Server
+      const verificationResp = await api<{ verified: boolean }>("/api/auth/webauthn/register/verify", {
+        method: "POST",
+        body: JSON.stringify(attResp),
+      });
+
+      if (verificationResp.verified) {
+        toast.success("Biometric verified! VIP Access granted.");
+        setStep('recovery');
+      } else {
+        throw new Error("Verification failed");
+      }
+    } catch (error: any) {
+      if (error.name === 'NotAllowedError') {
+        toast.error("Biometric scan cancelled.");
+      } else {
+        toast.error(`Error: ${error.message}`);
+      }
+    } finally {
+      setIsVerifyingBio(false);
+    }
+  };
+
+  const handleSkipBiometric = () => {
+    toast('You can verify later in Settings to unlock full features.', { icon: 'ðŸ”’' });
+    setStep('recovery');
+  };
+
   useEffect(() => {
     let timerId: NodeJS.Timeout;
-
     if (step === 'recovery' && !recoveryPhrase) {
-      // If phrase is lost (e.g. refresh), just go to chat.
       toast.success("Welcome! You can view your recovery phrase in Settings.");
       timerId = setTimeout(() => navigate('/chat'), 100);
     }
-
-    return () => {
-      if (timerId) clearTimeout(timerId);
-    };
+    return () => { if (timerId) clearTimeout(timerId); };
   }, [step, recoveryPhrase, navigate]);
 
-  // STEP 2: RECOVERY PHRASE
+  // STEP 3: RECOVERY PHRASE
   if (step === 'recovery') {
     if (!recoveryPhrase) return null;
-
     return <RecoveryPhraseModal phrase={recoveryPhrase} onClose={() => navigate('/chat')} />
   }
 
+  // STEP 2: BIOMETRIC VERIFICATION
+  if (step === 'biometric') {
+    return (
+      <div className="min-h-screen flex items-center justify-center bg-stone-900 p-4">
+        <div className="max-w-md w-full bg-stone-800 rounded-2xl p-8 shadow-2xl border border-stone-700 text-center">
+          <div className="w-16 h-16 bg-teal-500/10 rounded-full flex items-center justify-center mx-auto mb-6 text-teal-500">
+            <IoFingerPrint size={32} />
+          </div>
+          
+          <h2 className="text-2xl font-black text-white mb-2 tracking-tight">TRUST LEVEL VERIFICATION</h2>
+          <p className="text-stone-400 text-sm mb-8">
+            Verify you are human using your device's biometric sensor. 
+            Verified accounts get unlimited access. Unverified accounts are sandboxed.
+          </p>
+
+          {isBiometricsSupported ? (
+            <div className="space-y-4">
+              <button
+                onClick={handleBiometricRegister}
+                disabled={isVerifyingBio}
+                className="w-full py-4 rounded-xl bg-teal-500 hover:bg-teal-400 text-stone-900 font-bold uppercase tracking-wider shadow-lg shadow-teal-500/20 transition-all flex items-center justify-center gap-2"
+              >
+                {isVerifyingBio ? <span className="animate-pulse">Scanning...</span> : (
+                  <>
+                    <FiShield /> Verify Identity
+                  </>
+                )}
+              </button>
+              
+              <button
+                onClick={handleSkipBiometric}
+                className="w-full py-4 rounded-xl bg-transparent border border-stone-600 text-stone-400 hover:text-white hover:border-stone-500 font-bold uppercase tracking-wider transition-all flex items-center justify-center gap-2"
+              >
+                <FiSkipForward /> Skip for now
+              </button>
+            </div>
+          ) : (
+            <div className="space-y-4">
+              <div className="p-4 bg-yellow-500/10 border border-yellow-500/20 rounded-xl text-yellow-500 text-xs">
+                Your device does not support biometric authentication. You will start in Sandbox mode.
+              </div>
+              <button
+                onClick={handleSkipBiometric}
+                className="w-full py-4 rounded-xl bg-stone-700 hover:bg-stone-600 text-white font-bold uppercase tracking-wider transition-all"
+              >
+                Continue to App
+              </button>
+            </div>
+          )}
+        </div>
+      </div>
+    );
+  }
+
   // STEP 1: REGISTER FORM
   return (
     <div className="min-h-screen flex flex-col md:flex-row bg-stone-900">
