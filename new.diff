diff --git a/pnpm-lock.yaml b/pnpm-lock.yaml
index 0a502ef3..a73fecb7 100644
--- a/pnpm-lock.yaml
+++ b/pnpm-lock.yaml
@@ -271,9 +271,6 @@ importers:
       lodash:
         specifier: ^4.17.21
         version: 4.17.23
-      lucide-react:
-        specifier: ^0.575.0
-        version: 0.575.0(react@19.2.4)
       react:
         specifier: ^19.2.4
         version: 19.2.4
@@ -5276,11 +5273,6 @@ packages:
     resolution: {integrity: sha512-jumlc0BIUrS3qJGgIkWZsyfAM7NCWiBcCDhnd+3NNM5KbBmLTgHVfWBcg6W+rLUsIpzpERPsvwUP7CckAQSOoA==}
     engines: {node: '>=12'}
 
-  lucide-react@0.575.0:
-    resolution: {integrity: sha512-VuXgKZrk0uiDlWjGGXmKV6MSk9Yy4l10qgVvzGn2AWBx1Ylt0iBexKOAoA6I7JO3m+M9oeovJd3yYENfkUbOeg==}
-    peerDependencies:
-      react: ^16.5.1 || ^17.0.0 || ^18.0.0 || ^19.0.0
-
   lz-string@1.5.0:
     resolution: {integrity: sha512-h5bgJWpxJNswbU7qCrV0tIKQCaS3blPDrqKWx+QxzuzL1zGUzij9XCWLrSLsJPu5t+eWA/ycetzYAO5IOMcWAQ==}
     hasBin: true
@@ -13437,10 +13429,6 @@ snapshots:
 
   lru-cache@7.18.3: {}
 
-  lucide-react@0.575.0(react@19.2.4):
-    dependencies:
-      react: 19.2.4
-
   lz-string@1.5.0: {}
 
   magic-string@0.25.9:
diff --git a/server/src/config.ts b/server/src/config.ts
index 9ce23ced..6b10e4fb 100644
--- a/server/src/config.ts
+++ b/server/src/config.ts
@@ -16,11 +16,11 @@ if (process.env.NODE_ENV === 'production' && (!process.env.JWT_SECRET || process
 export const env = {
   port: parseInt(process.env.PORT || '4000', 10),
   corsOrigin: process.env.CORS_ORIGIN || 'https://nyx-app.my.id',
-
+  
   // --- DITAMBAHKAN AGAR BUILD BERHASIL ---
   appUrl: process.env.APP_URL || 'https://api.nyx-app.my.id',
   // ---------------------------------------
-
+  
   jwtSecret: process.env.JWT_SECRET || (() => {
     if (process.env.NODE_ENV === 'production') {
       throw new Error('JWT_SECRET is required in production environment')
diff --git a/server/src/jobs/messageSweeper.ts b/server/src/jobs/messageSweeper.ts
index 24adbce4..3d137ef7 100644
--- a/server/src/jobs/messageSweeper.ts
+++ b/server/src/jobs/messageSweeper.ts
@@ -5,7 +5,7 @@ import { getIo } from '../socket.js';
 // Jalanin fungsi ini setiap 1 menit (* * * * *)
 export const startMessageSweeper = () => {
   console.log('ðŸ§¹ Message Sweeper Job started...');
-
+  
   cron.schedule('* * * * *', async () => {
     try {
       const now = new Date();
@@ -15,11 +15,11 @@ export const startMessageSweeper = () => {
       while (true) {
         // 1. Cari pesan yang waktunya udah kelewat (Batching)
         const expiredMessages = await prisma.message.findMany({
-          where: {
-            expiresAt: {
+          where: { 
+            expiresAt: { 
               not: null,
-              lte: now
-            }
+              lte: now 
+            } 
           },
           select: { id: true, conversationId: true },
           take: BATCH_SIZE
@@ -28,7 +28,7 @@ export const startMessageSweeper = () => {
         if (expiredMessages.length === 0) break; // Selesai
 
         const messageIds = expiredMessages.map(m => m.id);
-
+        
         console.log(`ðŸ”¥ Sweeping batch of ${messageIds.length} expired messages...`);
 
         // 3. HAPUS PERMANEN DARI DATABASE!
@@ -40,7 +40,7 @@ export const startMessageSweeper = () => {
         const io = getIo();
         if (io) {
           const messagesByConvo: Record<string, string[]> = {};
-
+          
           expiredMessages.forEach(m => {
             if (!messagesByConvo[m.conversationId]) {
               messagesByConvo[m.conversationId] = [];
@@ -52,16 +52,16 @@ export const startMessageSweeper = () => {
             io.to(convoId).emit('messages:expired', { messageIds: ids });
           });
         }
-
+        
         processedCount += expiredMessages.length;
         // Optional: Small delay to let event loop breathe if heavily loaded
         await new Promise(r => setTimeout(r, 50));
       }
-
+      
       if (processedCount > 0) console.log(`âœ… Total swept: ${processedCount}`);
 
     } catch (error) {
       console.error('âŒ Message Sweeper Error:', error);
     }
-  }, { noOverlap: true });
+  });
 };
diff --git a/server/src/jobs/systemSweeper.ts b/server/src/jobs/systemSweeper.ts
index 7edd25a5..c646186f 100644
--- a/server/src/jobs/systemSweeper.ts
+++ b/server/src/jobs/systemSweeper.ts
@@ -4,7 +4,7 @@ import { prisma } from '../lib/prisma.js';
 // Jadwalkan untuk jalan setiap jam 3 pagi (server time) tiap hari
 export const startSystemSweeper = () => {
   console.log('ðŸ§¹ System Sweeper Job scheduled (Daily at 03:00)...');
-
+  
   cron.schedule('0 3 * * *', async () => {
     console.log('[Cron] Memulai pembersihan database harian...');
     const now = new Date();
@@ -36,10 +36,11 @@ export const startSystemSweeper = () => {
           ]
         }
       });
-
+      
       if (deletedSessionKeys.count > 0) {
         console.log(`[Cron] Berhasil menghapus ${deletedSessionKeys.count} kunci sesi kadaluarsa/usang.`);
       }
+
     } catch (error) {
       console.error('[Cron] Gagal melakukan pembersihan database:', error);
     }
diff --git a/server/src/routes/ai.ts b/server/src/routes/ai.ts
index d707549d..d313b9e6 100644
--- a/server/src/routes/ai.ts
+++ b/server/src/routes/ai.ts
@@ -10,7 +10,7 @@ const genAI = new GoogleGenerativeAI(process.env.GEMINI_API_KEY || '');
 router.post('/smart-reply', requireAuth, generalLimiter, async (req, res) => {
   try {
     const { message } = req.body;
-
+    
     if (!message || message.trim() === '') {
       return res.status(400).json({ error: 'Message is required' });
     }
@@ -22,16 +22,16 @@ router.post('/smart-reply', requireAuth, generalLimiter, async (req, res) => {
         responseMimeType: "application/json",
       }
     });
-
+    
     // Strict Prompt Engineering for JSON Array output
     const prompt = `You are a chat AI. Based on this message: "${message}"
 Create 3 short casual reply options (max 3 words per reply) in the same language.
 Output must be a JSON array of strings.`;
 
     const result = await model.generateContent(prompt);
-
+    
     let replies: string[] = [];
-
+    
     try {
       replies = JSON.parse(result.response.text());
     } catch (parseError) {
@@ -42,7 +42,7 @@ Output must be a JSON array of strings.`;
 
     // Return to frontend
     res.json({ replies });
-
+    
   } catch (error) {
     console.error('AI Error:', error);
     res.status(500).json({ error: 'Failed to generate smart replies' });
diff --git a/server/src/routes/auth.ts b/server/src/routes/auth.ts
index 221079d8..42ce7f22 100644
--- a/server/src/routes/auth.ts
+++ b/server/src/routes/auth.ts
@@ -263,45 +263,23 @@ router.post('/refresh', async (req, res, next) => {
 })
 
 // === ZERO-KNOWLEDGE ACCOUNT RECOVERY ===
-router.get('/recover/challenge', authLimiter, async (req, res, next) => {
-  try {
-    const { identifier } = req.query;
-    if (!identifier || typeof identifier !== 'string') {
-      throw new ApiError(400, "Identifier is required.");
-    }
-    const nonce = crypto.randomBytes(32).toString('hex');
-    await redisClient.setEx(`recover_nonce:${identifier}`, 300, nonce); // 5 mins expiry
-    res.json({ nonce });
-  } catch (e) {
-    next(e);
-  }
-});
-
 router.post('/recover', authLimiter, zodValidate({
   body: z.object({
     identifier: z.string().min(10), // usernameHash
     newPassword: z.string().min(8),
     newEncryptedKeys: z.string(),
     signature: z.string(),
-    timestamp: z.number(),
-    nonce: z.string()
+    timestamp: z.number()
   })
 }), async (req, res, next) => {
   try {
-    const { identifier: usernameHash, newPassword, newEncryptedKeys, signature, timestamp, nonce } = req.body;
+    const { identifier: usernameHash, newPassword, newEncryptedKeys, signature, timestamp } = req.body;
 
     const now = Date.now();
     if (Math.abs(now - timestamp) > 5 * 60 * 1000) {
        throw new ApiError(400, "Recovery request expired.");
     }
 
-    // Verify and consume server-side nonce
-    const cachedNonce = await redisClient.get(`recover_nonce:${usernameHash}`);
-    if (!cachedNonce || cachedNonce !== nonce) {
-       throw new ApiError(401, "Invalid or expired recovery challenge. Please try again.");
-    }
-    await redisClient.del(`recover_nonce:${usernameHash}`); // One-time use replay protection
-
     // Match by Hash
     const user = await prisma.user.findUnique({
       where: { usernameHash }
@@ -311,8 +289,8 @@ router.post('/recover', authLimiter, zodValidate({
     const { getSodium } = await import('../lib/sodium.js');
     const sodium = await getSodium();
     
-    // Canonicalize and concatenate full recovery payload
-    const messageString = `${usernameHash}:${timestamp}:${nonce}:${newPassword}:${newEncryptedKeys}`;
+    // Message: HASH:TIMESTAMP
+    const messageString = `${usernameHash}:${timestamp}`;
     const messageBytes = Buffer.from(messageString, 'utf-8');
     const signatureBytes = sodium.from_base64(signature, sodium.base64_variants.URLSAFE_NO_PADDING);
     const publicKeyBytes = sodium.from_base64(user.signingKey, sodium.base64_variants.URLSAFE_NO_PADDING);
@@ -323,20 +301,19 @@ router.post('/recover', authLimiter, zodValidate({
     }
 
     const passwordHash = await hashPassword(newPassword);
+    
+    await prisma.refreshToken.deleteMany({ where: { userId: user.id } });
+
+    const updatedUser = await prisma.user.update({
+      where: { id: user.id },
+      data: { 
+        passwordHash, 
+        encryptedPrivateKey: newEncryptedKeys 
+      }
+    });
 
-    const [updatedUser] = await prisma.$transaction([
-        prisma.user.update({
-          where: { id: user.id },
-          data: {
-            passwordHash,
-            encryptedPrivateKey: newEncryptedKeys
-          }
-        }),
-        prisma.refreshToken.deleteMany({ where: { userId: user.id } }),
-        prisma.authenticator.deleteMany({ where: { userId: user.id } })
-    ]);
-
-    const tokens = await issueTokens(updatedUser, req);    setAuthCookies(res, tokens);
+    const tokens = await issueTokens(updatedUser, req);
+    setAuthCookies(res, tokens);
 
     res.json({ message: "Account recovered successfully.", accessToken: tokens.access });
   } catch (e) {
diff --git a/server/src/routes/conversations.ts b/server/src/routes/conversations.ts
index 8c5d34aa..5bb0443c 100644
--- a/server/src/routes/conversations.ts
+++ b/server/src/routes/conversations.ts
@@ -113,12 +113,14 @@ router.post('/', async (req, res, next) => {
 
       if (existingConversation) return res.status(200).json(existingConversation)
         
-      // SANDBOX DM LIMIT CHECK (Only for NEW conversations)
+      // SANDBOX DM LIMIT (Only for NEW conversations)
       if (!isVerified) {
           const today = new Date().toISOString().split('T')[0];
           const key = `sandbox:newchat:${creatorId}:${today}`;
-          const currentCount = await redisClient.get(key);
-          if (currentCount && parseInt(currentCount as string, 10) >= 3) {
+          const count = await redisClient.incr(key);
+          if (count === 1) await redisClient.expire(key, 86400); // 24h
+          
+          if (count > 3) {
               throw new ApiError(429, 'SANDBOX_NEW_CHAT_LIMIT: Max 3 new conversations per day.');
           }
       }
@@ -171,13 +173,6 @@ router.post('/', async (req, res, next) => {
       return conversation
     })
 
-    // SANDBOX DM LIMIT INCREMENT (Atomic after success)
-    if (!isVerified && !isGroup) {
-        const today = new Date().toISOString().split('T')[0];
-        const key = `sandbox:newchat:${creatorId}:${today}`;
-        await redisClient.multi().incr(key).expire(key, 86400).exec();
-    }
-
     const transformedConversation = {
       ...newConversation,
       isGroup: newConversation.isGroup,
diff --git a/server/src/routes/keys.ts b/server/src/routes/keys.ts
index 51900afb..dacb9813 100644
--- a/server/src/routes/keys.ts
+++ b/server/src/routes/keys.ts
@@ -154,7 +154,7 @@ router.get(
       // 2. Atomic Pop: Fetch ONE OTPK and Delete it
       // Prisma doesn't support "DELETE RETURNING" directly in standard API easily for this logic without raw query or transaction.
       // We use a transaction: Find First -> Delete ID.
-
+      
       const otpk = await prisma.$transaction(async (tx) => {
         const key = await tx.oneTimePreKey.findFirst({
           where: { userId },
diff --git a/server/src/routes/sessions.ts b/server/src/routes/sessions.ts
index 7862e371..07a8d597 100644
--- a/server/src/routes/sessions.ts
+++ b/server/src/routes/sessions.ts
@@ -13,7 +13,7 @@ const router: Router = Router()
 router.get('/', requireAuth, async (req, res, next) => {
   try {
     if (!req.user) throw new ApiError(401, 'Authentication required.')
-
+    
     let currentJti: string | null = null
     if (req.cookies.rt) {
       const payload = verifyJwt(req.cookies.rt)
@@ -41,7 +41,7 @@ router.get('/', requireAuth, async (req, res, next) => {
       const browser = parser.getBrowser()
       const os = parser.getOS()
       const device = parser.getDevice()
-
+      
       const deviceInfo = [
         device.vendor,
         device.model,
diff --git a/server/src/routes/uploads.ts b/server/src/routes/uploads.ts
index f6c9fd61..c9004ed9 100644
--- a/server/src/routes/uploads.ts
+++ b/server/src/routes/uploads.ts
@@ -55,7 +55,7 @@ router.post('/presigned', requireAuth, uploadLimiter, async (req, res, next) =>
       'video/mp4', 'video/quicktime', 'video/x-msvideo',
       'audio/mpeg', 'audio/wav', 'audio/webm', 'audio/mp3',
       'application/zip', 'application/x-rar-compressed',
-      'application/octet-stream'
+      'application/octet-stream' 
     ]
 
     if (!allowedTypes.includes(fileType)) {
@@ -64,10 +64,10 @@ router.post('/presigned', requireAuth, uploadLimiter, async (req, res, next) =>
 
     const fileSize = req.body.fileSize ? parseInt(req.body.fileSize, 10) : 0
     if (fileSize > 0) {
-      const avatarMaxSize = 5 * 1024 * 1024
-      const imageMaxSize = 15 * 1024 * 1024
-      const videoMaxSize = 100 * 1024 * 1024
-      const documentMaxSize = 50 * 1024 * 1024
+      const avatarMaxSize = 5 * 1024 * 1024 
+      const imageMaxSize = 15 * 1024 * 1024 
+      const videoMaxSize = 100 * 1024 * 1024 
+      const documentMaxSize = 50 * 1024 * 1024 
 
       let maxSize: number
       if (targetFolder === 'avatars') {
@@ -77,7 +77,7 @@ router.post('/presigned', requireAuth, uploadLimiter, async (req, res, next) =>
       } else if (fileType.startsWith('video/')) {
         maxSize = videoMaxSize
       } else if (fileType.startsWith('audio/')) {
-        maxSize = videoMaxSize
+        maxSize = videoMaxSize 
       } else if (fileType.startsWith('application/') || fileType === 'text/plain') {
         maxSize = documentMaxSize
       } else {
@@ -87,12 +87,11 @@ router.post('/presigned', requireAuth, uploadLimiter, async (req, res, next) =>
       // Encryption Overhead Buffer (IV + Auth Tag + Margin)
       // AES-GCM adds ~28 bytes. We add 1KB to be safe.
       const ENCRYPTION_OVERHEAD = 1024; 
-      const allowedMax = maxSize + ENCRYPTION_OVERHEAD;
-
-      if (fileSize > allowedMax) {
-        const allowedMaxMB = (allowedMax / (1024 * 1024)).toFixed(2)
+      
+      if (fileSize > (maxSize + ENCRYPTION_OVERHEAD)) {
+        const maxSizeMB = maxSize / (1024 * 1024)
         return res.status(400).json({
-          error: `File too large. Maximum size for this file type is ${allowedMaxMB}MB (including encryption overhead).`
+          error: `File too large. Maximum size for this file type is ${maxSizeMB}MB.`
         })
       }
     }
@@ -103,7 +102,7 @@ router.post('/presigned', requireAuth, uploadLimiter, async (req, res, next) =>
     }
 
     const key = `${targetFolder}/${req.user!.id}-${nanoid()}.${ext}`
-
+    
     // [FIX] Force Content-Type to octet-stream because file is ENCRYPTED
     const uploadUrl = await getPresignedUploadUrl(key, 'application/octet-stream')
 
@@ -118,10 +117,44 @@ router.post('/presigned', requireAuth, uploadLimiter, async (req, res, next) =>
   }
 })
 
-// User avatars are now E2E Encrypted and updated via PUT /api/users/me along with the profile.
-// The server cannot decrypt the profile to extract the old avatar URL, so client must handle garbage collection or rely on orphaned file cleanup.
+// === 1. SIMPAN AVATAR USER ===
+router.post(
+  '/avatars/save', 
+  requireAuth,
+  uploadLimiter,
+  async (req: Request, res: Response, next: NextFunction) => {
+    try {
+      const { fileUrl } = req.body 
+      if (!req.user) throw new ApiError(401, 'Unauthorized')
+      if (!fileUrl) throw new ApiError(400, 'Missing fileUrl.')
+
+      const userId = req.user.id
+      const oldUser = await prisma.user.findUnique({
+        where: { id: userId },
+        select: { avatarUrl: true }
+      })
+
+      if (oldUser?.avatarUrl) {
+        deleteOldFile(oldUser.avatarUrl).catch(console.error)
+      }
+
+      const updatedUser = await prisma.user.update({
+        where: { id: userId },
+        data: { avatarUrl: fileUrl },
+        select: {
+          id: true, encryptedProfile: true, avatarUrl: true,
+          hasCompletedOnboarding: true, isVerified: true
+        }
+      })
+
+      res.json(updatedUser)
+    } catch (e) {
+      next(e)
+    }
+  }
+)
 
-// === 1. SIMPAN AVATAR GROUP ===
+// === 2. SIMPAN AVATAR GROUP ===
 router.post(
   '/groups/:id/avatar',
   uploadLimiter,
@@ -179,4 +212,4 @@ router.post(
     }
   })
 
-export default router
+export default router
\ No newline at end of file
diff --git a/server/src/routes/users.ts b/server/src/routes/users.ts
index 54593473..4654d1d0 100644
--- a/server/src/routes/users.ts
+++ b/server/src/routes/users.ts
@@ -19,7 +19,7 @@ router.get('/search', async (req, res, next) => {
     }
 
     // q adalah usernameHash yang dikirim client
-
+    
     // SANDBOX CHECK
     const user = await prisma.user.findUnique({ where: { id: req.user!.id }, select: { isVerified: true } });
     const limit = user?.isVerified ? 20 : 3;
@@ -75,11 +75,10 @@ router.put('/me',
   }),
   async (req, res, next) => {
     try {
-      const userId = req.user!.id
       const { encryptedProfile } = req.body
 
       const updatedUser = await prisma.user.update({
-        where: { id: userId },
+        where: { id: req.user!.id },
         data: { encryptedProfile },
         select: {
           id: true,
@@ -89,24 +88,7 @@ router.put('/me',
         }
       })
 
-      // Notify the user themselves (all their active devices)
-      getIo().to(userId).emit('user:updated', { id: updatedUser.id, encryptedProfile: updatedUser.encryptedProfile })
-
-      // Notify contacts
-      const conversations = await prisma.conversation.findMany({
-        where: { participants: { some: { userId } } },
-        include: { participants: { select: { userId: true } } }
-      })
-
-      const recipients = new Set<string>()
-      conversations.forEach(c => c.participants.forEach(p => {
-        if (p.userId !== userId) recipients.add(p.userId)
-      }))
-
-      recipients.forEach(recipientId => {
-        getIo().to(recipientId).emit('user:updated', { id: updatedUser.id, encryptedProfile: updatedUser.encryptedProfile })
-      })
-
+      getIo().emit('user:updated', { id: updatedUser.id, encryptedProfile: updatedUser.encryptedProfile })
       res.json(updatedUser)
     } catch (error) {
       next(error)
@@ -227,7 +209,7 @@ router.get('/me/blocked', async (req, res, next) => {
 })
 
 // DELETE Account (Self-Destruct)
-router.delete('/me',
+router.delete('/me', 
   zodValidate({
     body: z.object({
       password: z.string().min(1),
@@ -243,31 +225,16 @@ router.delete('/me',
       // 1. Re-verify Password (Security Check)
       const user = await prisma.user.findUnique({ where: { id: userId } })
       if (!user) throw new ApiError(404, 'User not found')
-
+      
       const isPasswordValid = await import('../utils/password.js').then(m => m.verifyPassword(password, user.passwordHash))
       if (!isPasswordValid) throw new ApiError(401, 'Invalid password. Account deletion aborted.')
 
       // 2. Cleanup Storage (R2)
       // Since we don't store file keys in DB, we rely on the client to tell us what to delete.
-      if (fileKeys && Array.isArray(fileKeys) && fileKeys.length > 0) {
+      if (fileKeys && fileKeys.length > 0) {
          try {
-             // VALIDATION: Ensure the user is only deleting their OWN files.
-             // Our R2 object keys always start with: `${targetFolder}/${userId}-...`
-             const validKeys = fileKeys.filter(key => {
-                 if (typeof key !== 'string') return false;
-                 // Split by folder, e.g., "images/cl123456-abcdef.png" -> ["images", "cl123456-abcdef.png"]
-                 const parts = key.split('/');
-                 if (parts.length < 2) return false;
-                 const filename = parts[parts.length - 1];
-                 return filename.startsWith(`${userId}-`);
-             });
-
-             if (validKeys.length > 0) {
-                 const { deleteR2Files } = await import('../utils/r2.js')
-                 await deleteR2Files(validKeys)
-             } else {
-                 console.warn(`User ${userId} attempted to delete invalid or unauthorized R2 keys.`);
-             }
+             const { deleteR2Files } = await import('../utils/r2.js')
+             await deleteR2Files(fileKeys)
          } catch (e) {
              console.error("Failed to cleanup R2 files:", e)
              // Continue deletion anyway
diff --git a/server/src/socket.ts b/server/src/socket.ts
index 0cbc73ee..c9c106d2 100644
--- a/server/src/socket.ts
+++ b/server/src/socket.ts
@@ -208,21 +208,6 @@ export function registerSocket(httpServer: HttpServer) {
          }
       });
 
-      // MIGRATION GUEST RECEIVER
-      socket.on('migration:join', (roomId: string) => {
-        if (typeof roomId === 'string' && roomId.startsWith('mig_') && roomId.length > 20) {
-          socket.join(roomId);
-        } else {
-          socket.emit("error", { message: "Invalid migration room" });
-        }
-      });
-
-      socket.on('migration:ack', (data: { roomId: string, success: boolean }) => {
-        if (data && data.roomId) {
-           socket.to(data.roomId).emit('migration:ack', data);
-        }
-      });
-
       socket.on("disconnect", () => {
       });
 
@@ -537,35 +522,14 @@ export function registerSocket(httpServer: HttpServer) {
 
     // === DEVICE MIGRATION TUNNEL ===
     socket.on('migration:join', (roomId: string) => {
-      // Allow logged-in user to join a migration room (just in case they are the receiver somehow)
-      if (typeof roomId === 'string' && roomId.startsWith('mig_') && roomId.length > 20) {
-        socket.join(roomId);
-      } else {
-        socket.emit("error", { message: "Invalid migration room" });
-      }
+      socket.join(roomId);
     });
 
-    socket.on('migration:start', async (data: { roomId: string, totalChunks: number, sealedKey: string, iv: string }) => {
-      if (!data || !data.roomId || typeof data.roomId !== 'string' || !data.roomId.startsWith('mig_')) {
-        socket.emit("error", { message: "Invalid migration room payload" });
-        return;
-      }
-      
-      // Mark ownership of this room to the current authenticated user
-      await redisClient.setEx(`migration_owner:${data.roomId}`, 3600, userId);
+    socket.on('migration:start', (data: { roomId: string, totalChunks: number, sealedKey: string, iv: string }) => {
       socket.to(data.roomId).emit('migration:start', data);
     });
 
-    socket.on('migration:chunk', async (data: { roomId: string, chunkIndex: number, chunk: any }) => {
-      if (!data || !data.roomId || typeof data.roomId !== 'string') return;
-      
-      // Verify ownership
-      const ownerId = await redisClient.get(`migration_owner:${data.roomId}`);
-      if (ownerId !== userId) {
-        socket.emit("error", { message: "Permission denied for this migration room" });
-        return;
-      }
-      
+    socket.on('migration:chunk', (data: { roomId: string, chunkIndex: number, chunk: any }) => {
       socket.to(data.roomId).emit('migration:chunk', data);
     });
 
diff --git a/server/src/utils/r2.ts b/server/src/utils/r2.ts
index 8067c2f6..cba1e7dd 100644
--- a/server/src/utils/r2.ts
+++ b/server/src/utils/r2.ts
@@ -40,8 +40,8 @@ export const deleteR2File = async (key: string) => {
 
 // Hapus BANYAK file sekaligus (Batch Delete)
 export const deleteR2Files = async (keys: string[]) => {
-  if (keys.length === 0) return
-
+  if (keys.length === 0) return;
+  
   const command = new DeleteObjectsCommand({
     Bucket: env.r2BucketName,
     Delete: {
diff --git a/server/src/utils/secureLinkPreview.ts b/server/src/utils/secureLinkPreview.ts
index fd8b5fe0..832af9e0 100644
--- a/server/src/utils/secureLinkPreview.ts
+++ b/server/src/utils/secureLinkPreview.ts
@@ -49,13 +49,13 @@ async function validateRedirectChain(initialUrl: string): Promise<string> {
     // We catch errors here to handle network failures gracefully during validation
     try {
       const res = await fetch(currentUrl, { method: 'HEAD', redirect: 'manual' })
-
+      
       if (res.status >= 300 && res.status < 400) {
         const location = res.headers.get('location')
         if (!location) {
            return currentUrl // Redirect without location, treat as final
         }
-
+        
         // Resolve relative URLs
         currentUrl = new URL(location, currentUrl).toString()
         redirectCount++
@@ -89,7 +89,7 @@ export async function getSecureLinkPreview (url: string): Promise<LinkPreview> {
     // We disable following redirects here because we already found the final one
     const preview = await getLinkPreview(safeUrl, {
       timeout: 5000,
-      followRedirects: 'manual',
+      followRedirects: 'manual', 
       handleRedirects: (baseURL: string, forwardedURL: string) => {
         // Since we pre-validated the chain, we shouldn't encounter new redirects here.
         // If we do, it means the server changed behavior between HEAD and GET.
@@ -98,11 +98,11 @@ export async function getSecureLinkPreview (url: string): Promise<LinkPreview> {
         // Returning true usually implies "continue".
         // The library expects a function that returns a boolean or promise<boolean> to continue?
         // Wait, checking docs/types: handleRedirects?: (baseURL: string, forwardedURL: string) => boolean;
-
-        // Actually, looking at common usage, if followRedirects is manual,
-        // the library might expect US to do the fetching?
+        
+        // Actually, looking at common usage, if followRedirects is manual, 
+        // the library might expect US to do the fetching? 
         // No, 'manual' in link-preview-js means "I will tell you if you should follow this redirect".
-
+        
         // Let's check the error message implication: "no handleRedirects function is provided".
         // Providing a simple function that returns false (stop redirects) is safest since we fetched the final URL.
         return false;
diff --git a/web/package.json b/web/package.json
index a434ef06..8c9a2706 100644
--- a/web/package.json
+++ b/web/package.json
@@ -32,7 +32,6 @@
     "libsodium-wrappers": "^0.7.15",
     "lighthouse": "^13.0.2",
     "lodash": "^4.17.21",
-    "lucide-react": "^0.575.0",
     "react": "^19.2.4",
     "react-dom": "^19.2.4",
     "react-hot-toast": "^2.6.0",
diff --git a/web/src/App.tsx b/web/src/App.tsx
index cc8ed754..e2b37ff3 100644
--- a/web/src/App.tsx
+++ b/web/src/App.tsx
@@ -28,7 +28,6 @@ import PasswordPromptModal from './components/PasswordPromptModal';
 import ChatInfoModal from './components/ChatInfoModal';
 import DynamicIsland from './components/DynamicIsland';
 import CommandPalette from './components/CommandPalette';
-import ContextMenu from './components/ContextMenu';
 import { Spinner } from './components/Spinner';
 
 // Stores & Hooks
@@ -131,10 +130,6 @@ const AppContent = () => {
 
   // --- Lifecycle & Effects ---
 
-  const isDeviceFlow = useCallback((pathname: string) => {
-      return pathname.startsWith('/link-device') || pathname.startsWith('/migrate-receive');
-  }, []);
-
   // 1. Bootstrap Auth
   useEffect(() => {
     bootstrap();
@@ -142,7 +137,7 @@ const AppContent = () => {
 
   // 2. Manage Socket Connection
   useEffect(() => {
-    if (isDeviceFlow(location.pathname)) {
+    if (location.pathname.startsWith('/link-device')) {
       return;
     }
     if (user) {
@@ -150,7 +145,7 @@ const AppContent = () => {
     } else {
       disconnectSocket();
     }
-  }, [user, location.pathname, isDeviceFlow]);
+  }, [user, location.pathname]);
 
   // 3. (Reserved for future use)
 
@@ -166,7 +161,7 @@ const AppContent = () => {
   // 5. Visibility Change Handler
   useEffect(() => {
     const handleVisibilityChange = () => {
-      if (isDeviceFlow(location.pathname)) {
+      if (location.pathname.startsWith('/link-device')) {
         return;
       }
 
@@ -233,7 +228,6 @@ const AppContent = () => {
       <PasswordPromptModal />
       <ChatInfoModal />
       <DynamicIsland />
-      <ContextMenu />
 
       <div className="w-full h-dvh max-w-[1920px] mx-auto relative shadow-2xl overflow-hidden bg-bg-main">
         <Suspense fallback={<LoadingScreen />}>
diff --git a/web/src/components/ChatList.tsx b/web/src/components/ChatList.tsx
index 59d26d9c..02c60a0a 100644
--- a/web/src/components/ChatList.tsx
+++ b/web/src/components/ChatList.tsx
@@ -15,13 +15,13 @@ import type { Conversation } from '@store/conversation';
 
 import { toAbsoluteUrl } from '@utils/url';
 
-import { FiUsers, FiSearch, FiSettings, FiLogOut, FiUser, FiMaximize2, FiSlash, FiTrash2 } from 'react-icons/fi';
+import * as DropdownMenu from '@radix-ui/react-dropdown-menu';
+import { FiUsers, FiSearch, FiMoreVertical, FiSettings, FiLogOut } from 'react-icons/fi';
 
 import CreateGroupChat from './CreateGroupChat';
 import NotificationBell from './NotificationBell';
 import { Spinner } from './Spinner';
-import SwipeableItem from './SwipeableItem';
-import { useContextMenuStore } from '../store/contextMenu';
+
 
 // --- Sub-components ---
 
@@ -42,6 +42,7 @@ const UserProfile = memo(() => {
 
   return (
     <div className="flex items-center justify-between px-6 py-6 bg-bg-main z-10">
+      {/* Identity Slot */}
       <div className="flex items-center gap-3 overflow-hidden">
         <div className="relative flex-shrink-0">
           <img 
@@ -57,8 +58,10 @@ const UserProfile = memo(() => {
         </div>
       </div>
 
+      {/* Control Cluster */}
       <div className="flex items-center gap-1 flex-shrink-0">
         <NotificationBell />
+        
         <Link 
           to="/settings" 
           aria-label="Settings" 
@@ -66,6 +69,7 @@ const UserProfile = memo(() => {
         >
           <FiSettings size={20} />
         </Link>
+        
         <button 
           onClick={handleLogout} 
           aria-label="Logout" 
@@ -138,11 +142,10 @@ const ConversationItem = memo(({
   onTogglePin: (id: string) => void;
 }) => {
   const peerUser = !conversation.isGroup ? conversation.participants?.find(p => p.id !== meId) : null;
-  const peerProfile = useUserProfile(peerUser as any);
+  const peerProfile = useUserProfile(peerUser as any); // Cast as any because Participant might not perfectly match but has id and encryptedProfile
   const title = conversation.isGroup ? conversation.title : peerProfile.name || 'Conversation';
   const isUnread = conversation.unreadCount > 0;
   const isPinnedByMe = Boolean(conversation.participants?.some(p => p.id === meId && p.isPinned));
-  const openMenu = useContextMenuStore(s => s.openMenu);
 
   const avatarSrc = conversation.isGroup 
     ? (conversation.avatarUrl ? `${toAbsoluteUrl(conversation.avatarUrl)}?t=${conversation.lastUpdated}` : `https://api.dicebear.com/8.x/initials/svg?seed=${conversation.title}`)
@@ -159,21 +162,9 @@ const ConversationItem = memo(({
 
   const previewText = conversation.lastMessage?.content || conversation.lastMessage?.preview || 'No messages yet';
 
-  const handleContextMenu = (e: React.MouseEvent | React.TouchEvent) => {
-    e.preventDefault();
-    openMenu(e, [
-      ...(peerUser ? [{ label: 'View Profile', icon: <FiUser />, onClick: () => onUserClick(peerUser.id) }] : []),
-      { label: isPinnedByMe ? 'Unpin Chat' : 'Pin Chat', icon: <FiMaximize2 />, onClick: () => onTogglePin(conversation.id) },
-      ...(!conversation.isGroup ? [{ label: isBlocked ? 'Unblock User' : 'Block User', icon: <FiSlash />, onClick: () => {
-         const other = conversation.participants.find(p => p.id !== meId);
-         if (other) { isBlocked ? unblockUser(other.id) : blockUser(other.id); }
-      } }] : []),
-      { label: conversation.isGroup ? 'Delete Group' : 'Delete Chat', icon: <FiTrash2 />, destructive: true, onClick: () => onMenuSelect(conversation.isGroup ? 'deleteGroup' : 'deleteChat') },
-    ]);
-  };
-
   return (
     <motion.div 
+      // Removed 'layout' prop for performance
       key={conversation.id} 
       className={clsx(
         'relative mx-4 my-3 rounded-2xl p-1 transition-all duration-200 select-none group',
@@ -185,95 +176,144 @@ const ConversationItem = memo(({
       animate={{ opacity: 1, y: 0 }}
       transition={{ duration: 0.2 }}
     >
-      <SwipeableItem
-        leftAction={{ icon: <FiMaximize2 size={24} />, color: isPinnedByMe ? 'bg-blue-500' : 'bg-green-500', onAction: () => onTogglePin(conversation.id) }}
-        rightAction={{ icon: <FiTrash2 size={24} />, color: 'bg-red-500', onAction: () => onMenuSelect(conversation.isGroup ? 'deleteGroup' : 'deleteChat') }}
-      >
-        <div 
-          onContextMenu={handleContextMenu}
-          className="w-full text-left p-3 pr-4 flex items-center gap-4 cursor-pointer rounded-xl bg-bg-main" 
-          onClick={onClick}
-        >
-          {/* Avatar */}
-          <div className="relative flex-shrink-0">
-            <button 
-              onClick={(e) => {
-                if (peerUser) {
-                  e.stopPropagation();
-                  onUserClick(peerUser.id);
+      <div className="w-full text-left p-3 pr-8 flex items-center gap-4 cursor-pointer rounded-xl" onClick={onClick}>
+        {/* Avatar */}
+        <div className="relative flex-shrink-0">
+          <button 
+            onClick={(e) => {
+              if (peerUser) {
+                e.stopPropagation();
+                onUserClick(peerUser.id);
+              }
+            }}
+            disabled={!peerUser}
+            className="block"
+          >
+            <img
+              src={avatarSrc}
+              alt="Avatar"
+              className={clsx(
+                "w-12 h-12 rounded-full object-cover border-2 transition-all",
+                isActive ? "border-bg-surface shadow-inner" : "border-bg-main shadow-sm"
+              )}
+              onError={(e) => {
+                const target = e.target as HTMLImageElement;
+                if (conversation.isGroup) {
+                  target.src = `https://api.dicebear.com/8.x/initials/svg?seed=${conversation.title}`;
+                } else {
+                  target.src = `https://api.dicebear.com/8.x/initials/svg?seed=${title}`;
                 }
               }}
-              disabled={!peerUser}
-              className="block"
-            >
-              <img
-                src={avatarSrc}
-                alt="Avatar"
-                className={clsx(
-                  "w-12 h-12 rounded-full object-cover border-2 transition-all pointer-events-none",
-                  isActive ? "border-bg-surface shadow-inner" : "border-bg-main shadow-sm"
-                )}
-                onError={(e) => {
-                  const target = e.target as HTMLImageElement;
-                  if (conversation.isGroup) {
-                    target.src = `https://api.dicebear.com/8.x/initials/svg?seed=${conversation.title}`;
-                  } else {
-                    target.src = `https://api.dicebear.com/8.x/initials/svg?seed=${title}`;
-                  }
-                }}
-              />
-            </button>
-            {peerUser && (
-              <span className={`absolute bottom-0 right-0 w-3 h-3 rounded-full border-2 border-bg-surface ${isOnline ? 'bg-green-500' : 'bg-gray-400'}`} />
-            )}
-          </div>
+            />
+          </button>
+          {peerUser && (
+            <span className={`absolute bottom-0 right-0 w-3 h-3 rounded-full border-2 border-bg-surface ${isOnline ? 'bg-green-500' : 'bg-gray-400'}`} />
+          )}
+        </div>
 
-          {/* Info */}
-          <div className="flex-1 min-w-0 pointer-events-none">
-            <div className="flex justify-between items-center mb-0.5">
-              <div className="flex items-center gap-1.5 min-w-0">
-                {isPinnedByMe && (
-                  <span className="text-accent flex-shrink-0">
-                     <svg xmlns="http://www.w3.org/2000/svg" className="h-3 w-3" viewBox="0 0 24 24" fill="currentColor"><path d="M16 21v-2a4 4 0 0 0-4-4H6a4 4 0 0 0-4 4v2"/><circle cx="9" cy="7" r="4"/><path d="M22 21v-2a4 8 0 0 0-3-3.87"/><path d="M16 3.13a4 4 0 0 1 0 7.75"/></svg>
-                  </span>
-                )}
-                <p className={clsx(
-                  "text-sm font-bold truncate transition-colors",
-                  isActive ? 'text-accent' : 'text-text-primary'
-                )}>
-                  {title}
-                </p>
-              </div>
-              {conversation.lastMessage && (
-                <p className="text-[10px] font-medium text-text-secondary flex-shrink-0 opacity-80">
-                  {formatConversationTime(conversation.lastMessage.createdAt)}
-                </p>
+        {/* Info */}
+        <div className="flex-1 min-w-0">
+          <div className="flex justify-between items-center mb-0.5">
+            <div className="flex items-center gap-1.5 min-w-0">
+              {isPinnedByMe && (
+                <span className="text-accent flex-shrink-0">
+                   <svg xmlns="http://www.w3.org/2000/svg" className="h-3 w-3" viewBox="0 0 24 24" fill="currentColor"><path d="M16 21v-2a4 4 0 0 0-4-4H6a4 4 0 0 0-4 4v2"/><circle cx="9" cy="7" r="4"/><path d="M22 21v-2a4 8 0 0 0-3-3.87"/><path d="M16 3.13a4 4 0 0 1 0 7.75"/></svg>
+                </span>
               )}
-            </div>
-            
-            <div className="flex justify-between items-center">
               <p className={clsx(
-                "text-xs truncate max-w-[85%]",
-                isUnread ? 'font-bold text-text-primary' : 'text-text-secondary opacity-80'
+                "text-sm font-bold truncate transition-colors",
+                isActive ? 'text-accent' : 'text-text-primary'
               )}>
-                {previewText}
+                {title}
               </p>
-              {isUnread && (
-                <span className="
-                  flex items-center justify-center min-w-[1.25rem] h-5 px-1.5
-                  bg-accent text-white text-[10px] font-bold 
-                  rounded-full shadow-sm
-                ">
-                  {conversation.unreadCount}
-                </span>
-              )}
             </div>
+            {conversation.lastMessage && (
+              <p className="text-[10px] font-medium text-text-secondary flex-shrink-0 opacity-80">
+                {formatConversationTime(conversation.lastMessage.createdAt)}
+              </p>
+            )}
+          </div>
+          
+          <div className="flex justify-between items-center">
+            <p className={clsx(
+              "text-xs truncate max-w-[85%]",
+              isUnread ? 'font-bold text-text-primary' : 'text-text-secondary opacity-80'
+            )}>
+              {previewText}
+            </p>
+            {isUnread && (
+              <span className="
+                flex items-center justify-center min-w-[1.25rem] h-5 px-1.5
+                bg-accent text-white text-[10px] font-bold 
+                rounded-full shadow-sm
+              ">
+                {conversation.unreadCount}
+              </span>
+            )}
           </div>
         </div>
-      </SwipeableItem>
+      </div>
+
+      {/* Dropdown Menu */}
+      <div className="absolute right-2 top-1/2 -translate-y-1/2 opacity-0 group-hover:opacity-100 transition-opacity">
+        <DropdownMenu.Root>
+          <DropdownMenu.Trigger asChild>
+            <button 
+              onClick={(e) => e.stopPropagation()} 
+              aria-label="Options" 
+              className="
+                p-3 rounded-full text-text-secondary 
+                hover:bg-bg-main hover:text-accent
+                transition-colors
+              "
+            >
+              <FiMoreVertical size={16} />
+            </button>
+          </DropdownMenu.Trigger>
+          <DropdownMenu.Portal>
+            <DropdownMenu.Content sideOffset={5} align="end" className="
+              min-w-[160px] bg-bg-main 
+              rounded-xl shadow-neu-float dark:shadow-neu-float-dark
+              border border-white/50 dark:border-white/5
+              p-1.5 z-50
+            ">
+              <DropdownMenu.Item
+                onSelect={() => onTogglePin(conversation.id)}
+                className="w-full text-left px-3 py-2 text-xs font-medium rounded-lg cursor-pointer hover:bg-bg-main hover:text-accent outline-none transition-colors"
+              >
+                {isPinnedByMe ? 'Unpin' : 'Pin'} Chat
+              </DropdownMenu.Item>
+              
+              {!conversation.isGroup && (
+                <DropdownMenu.Item
+                  onSelect={() => {
+                    const other = conversation.participants.find(p => p.id !== meId);
+                    if (other) {
+                      isBlocked ? unblockUser(other.id) : blockUser(other.id);
+                    }
+                  }}
+                  className="w-full text-left px-3 py-2 text-xs font-medium rounded-lg cursor-pointer hover:bg-bg-main hover:text-accent outline-none transition-colors"
+                >
+                   {isBlocked ? 'Unblock' : 'Block'} User
+                </DropdownMenu.Item>
+              )}
+              
+              <div className="h-px bg-border my-1" />
+              
+              <DropdownMenu.Item
+                onSelect={() => onMenuSelect(conversation.isGroup ? 'deleteGroup' : 'deleteChat')}
+                className="w-full text-left px-3 py-2 text-xs font-medium text-red-500 rounded-lg cursor-pointer hover:bg-red-500/10 outline-none transition-colors"
+              >
+                {conversation.isGroup ? 'Delete Group' : 'Delete Chat'}
+              </DropdownMenu.Item>
+            </DropdownMenu.Content>
+          </DropdownMenu.Portal>
+        </DropdownMenu.Root>
+      </div>
     </motion.div>
   );
 }, (prev, next) => {
+  // Custom comparison for Memo
   return (
     prev.conversation === next.conversation &&
     prev.isActive === next.isActive &&
@@ -322,6 +362,7 @@ export default function ChatList() {
   }));
 
   const [showGroupModal, setShowGroupModal] = useState(false);
+  const [selectedIndex, setSelectedIndex] = useState(-1);
   const virtuosoRef = useRef<VirtuosoHandle>(null);
   const { addCommands, removeCommands } = useCommandPaletteStore();
 
@@ -336,6 +377,7 @@ export default function ChatList() {
     return () => removeCommands(commands.map(c => c.id));
   }, [addCommands, removeCommands, openCreateGroupModal]);
 
+  // Memoized Item Renderer to prevent re-creating the function on every render
   const itemContent = useCallback((index: number, c: Conversation) => {
     const peerUser = !c.isGroup ? c.participants?.find(p => p.id !== meId) : null;
     const isOnline = peerUser ? presence.includes(peerUser.id) : false;
@@ -359,7 +401,7 @@ export default function ChatList() {
         onTogglePin={togglePinConversation}
       />
     );
-  }, [meId, presence, blockedUserIds, activeId, handleConversationClick, openProfileModal, deleteGroup, deleteConversation, togglePinConversation, blockUser, unblockUser]);
+  }, [meId, presence, blockedUserIds, activeId, selectedIndex, handleConversationClick, openProfileModal, deleteGroup, deleteConversation, togglePinConversation, blockUser, unblockUser]);
 
   return (
     <div className="
@@ -449,4 +491,4 @@ export default function ChatList() {
       {showGroupModal && <CreateGroupChat onClose={() => setShowGroupModal(false)} />}
     </div>
   );
-}
+}
\ No newline at end of file
diff --git a/web/src/components/ContextMenu.tsx b/web/src/components/ContextMenu.tsx
deleted file mode 100644
index 66b85f9c..00000000
--- a/web/src/components/ContextMenu.tsx
+++ /dev/null
@@ -1,118 +0,0 @@
-import { useEffect, useRef, useState } from 'react';
-import { motion, AnimatePresence } from 'framer-motion';
-import { useContextMenuStore } from '../store/contextMenu';
-import clsx from 'clsx';
-
-export default function ContextMenu() {
-  const { isOpen, x, y, options, reactions, closeMenu } = useContextMenuStore();
-  const menuRef = useRef<HTMLDivElement>(null);
-  const [position, setPosition] = useState({ top: 0, left: 0 });
-
-  useEffect(() => {
-    if (isOpen && menuRef.current) {
-      const menuWidth = menuRef.current.offsetWidth;
-      const menuHeight = menuRef.current.offsetHeight;
-      const windowWidth = window.innerWidth;
-      const windowHeight = window.innerHeight;
-
-      let newLeft = x;
-      let newTop = y;
-
-      // Intelligent Edge Detection
-      if (x + menuWidth > windowWidth - 16) {
-        newLeft = x - menuWidth;
-      }
-      if (y + menuHeight > windowHeight - 16) {
-        newTop = y - menuHeight;
-      }
-
-      // Ensure it doesn't go off-screen to the top/left
-      newLeft = Math.max(16, newLeft);
-      newTop = Math.max(16, newTop);
-
-      setPosition({ left: newLeft, top: newTop });
-    }
-  }, [isOpen, x, y, options, reactions]);
-
-  // Click outside to close
-  useEffect(() => {
-    if (!isOpen) return;
-    const handleClickOutside = (e: MouseEvent | TouchEvent) => {
-      if (menuRef.current && !menuRef.current.contains(e.target as Node)) {
-        closeMenu();
-      }
-    };
-    
-    // Slight delay to prevent immediate closure if the trigger click propagated
-    setTimeout(() => {
-      document.addEventListener('mousedown', handleClickOutside);
-      document.addEventListener('touchstart', handleClickOutside);
-    }, 10);
-
-    return () => {
-      document.removeEventListener('mousedown', handleClickOutside);
-      document.removeEventListener('touchstart', handleClickOutside);
-    };
-  }, [isOpen, closeMenu]);
-
-  return (
-    <AnimatePresence>
-      {isOpen && (
-        <motion.div
-          ref={menuRef}
-          initial={{ opacity: 0, scale: 0.95, filter: 'blur(4px)' }}
-          animate={{ opacity: 1, scale: 1, filter: 'blur(0px)' }}
-          exit={{ opacity: 0, scale: 0.95, filter: 'blur(4px)' }}
-          transition={{ duration: 0.15, ease: 'easeOut' }}
-          style={{ top: position.top, left: position.left }}
-          className="fixed z-[100] min-w-[200px] flex flex-col rounded-2xl
-                     bg-bg-main/80 backdrop-blur-xl
-                     border border-white/20 dark:border-white/10
-                     shadow-[0_8px_32px_rgba(0,0,0,0.25)]
-                     dark:shadow-[0_8px_32px_rgba(0,0,0,0.5)]
-                     overflow-hidden"
-        >
-          {/* Reactions Row */}
-          {reactions && reactions.length > 0 && (
-            <div className="flex items-center justify-between p-2 border-b border-black/5 dark:border-white/5 bg-secondary/30">
-              {reactions.map((reaction, idx) => (
-                <button
-                  key={idx}
-                  onClick={() => {
-                    reaction.onClick();
-                    closeMenu();
-                  }}
-                  className="p-2 rounded-full hover:bg-accent/20 hover:scale-110 active:scale-95 transition-all text-xl"
-                >
-                  {reaction.emoji}
-                </button>
-              ))}
-            </div>
-          )}
-
-          {/* Options */}
-          <div className="flex flex-col py-1">
-            {options.map((option, idx) => (
-              <button
-                key={idx}
-                onClick={() => {
-                  option.onClick();
-                  closeMenu();
-                }}
-                className={clsx(
-                  "flex items-center gap-3 px-4 py-2.5 text-sm font-semibold transition-colors",
-                  option.destructive
-                    ? "text-red-500 hover:bg-red-500/10"
-                    : "text-text-primary hover:bg-white/10 dark:hover:bg-white/5"
-                )}
-              >
-                {option.icon && <span className="opacity-80">{option.icon}</span>}
-                <span>{option.label}</span>
-              </button>
-            ))}
-          </div>
-        </motion.div>
-      )}
-    </AnimatePresence>
-  );
-}
diff --git a/web/src/components/MessageItem.tsx b/web/src/components/MessageItem.tsx
index 8bd19d44..620aac98 100644
--- a/web/src/components/MessageItem.tsx
+++ b/web/src/components/MessageItem.tsx
@@ -3,20 +3,27 @@ import type { Message, Conversation, Participant, MessageStatus } from "@store/c
 import { useAuthStore } from "@store/auth";
 import { useMessageInputStore } from "@store/messageInput";
 import { getSocket } from "@lib/socket";
+import * as DropdownMenu from '@radix-ui/react-dropdown-menu';
 import { api } from "@lib/api";
+import ReactionPopover from "./Reactions";
 import { toAbsoluteUrl } from "@utils/url";
+import LazyImage from "./LazyImage";
+import FileAttachment from "./FileAttachment";
 import { useModalStore } from '@store/modal';
 import { motion } from 'framer-motion';
 import clsx from 'clsx';
-import { FiRefreshCw, FiShield, FiCopy, FiTrash2, FiCornerUpLeft, FiClock, FiInfo } from 'react-icons/fi';
+import LinkPreviewCard from './LinkPreviewCard';
+import { FiRefreshCw, FiShield, FiCopy, FiTrash2, FiCornerUpLeft, FiClock } from 'react-icons/fi';
 import { getUserColor } from '@utils/color';
 import { FaCheck, FaCheckDouble } from 'react-icons/fa';
+import VoiceMessagePlayer from './VoiceMessagePlayer';
+import { decryptMessage } from "@utils/crypto";
+import { useKeychainStore } from "@store/keychain";
 import { useMessageStore } from '@store/message';
 import toast from 'react-hot-toast';
-import MessageBubble from "./MessageBubble";
+import MarkdownMessage from './MarkdownMessage';
+import MessageBubble from "./MessageBubble"; // Import the external component
 import { useUserProfile } from '@hooks/useUserProfile';
-import SwipeableItem from "./SwipeableItem";
-import { useContextMenuStore } from "../store/contextMenu";
 
 const MessageStatusIcon = ({ message, participants }: { message: Message; participants: Participant[] }) => {
   const meId = useAuthStore((s) => s.user?.id);
@@ -24,6 +31,7 @@ const MessageStatusIcon = ({ message, participants }: { message: Message; partic
   
   if (message.senderId !== meId) return null;
   
+  // Prioritize explicit status field
   if (message.status === 'FAILED' || message.error) {
     return (
       <button onClick={() => retrySendMessage(message)} title="Failed to send. Click to retry.">
@@ -80,16 +88,13 @@ const MessageItem = ({ message, isGroup, participants, isHighlighted, onImageCli
   const meId = useAuthStore((s) => s.user?.id);
   const setReplyingTo = useMessageInputStore(state => state.setReplyingTo);
   const showConfirm = useModalStore(state => state.showConfirm);
-  const removeMessage = useMessageStore(state => state.removeMessage);
-  const addOptimisticMessage = useMessageStore(state => state.addOptimisticMessage);
-  const sendReaction = useMessageStore(state => state.sendReaction);
-  const removeLocalReaction = useMessageStore(state => state.removeLocalReaction);
-  const user = useAuthStore((s) => s.user);
-
+  const { removeMessage, addOptimisticMessage } = useMessageStore(state => ({
+    removeMessage: state.removeMessage,
+    addOptimisticMessage: state.addOptimisticMessage,
+  }));
   const profile = useUserProfile(message.sender as any);
   const mine = message.senderId === meId;
   const ref = useRef<HTMLDivElement>(null);
-  const openMenu = useContextMenuStore(s => s.openMenu);
 
   useEffect(() => {
     if (!ref.current || mine) return;
@@ -125,8 +130,13 @@ const MessageItem = ({ message, isGroup, participants, isHighlighted, onImageCli
 
   const handleDelete = () => {
     showConfirm('Delete Message', 'Are you sure you want to permanently delete this message?', () => {
+      // Optimistically remove the message from the UI
       removeMessage(message.conversationId, message.id);
+      
+      // Prepare Query Params for Blind Attachment Deletion
       let query = '';
+      
+      // Try to get real R2 URL from JSON content first (because fileUrl might be a Blob)
       let targetUrl = message.fileUrl;
       try {
           if (message.content && message.content.startsWith('{')) {
@@ -137,15 +147,18 @@ const MessageItem = ({ message, isGroup, participants, isHighlighted, onImageCli
 
       if (targetUrl && !targetUrl.startsWith('blob:')) {
           try {
+              // Extract key from URL (e.g. https://pub.r2.../attachments/key.ext -> attachments/key.ext)
               const url = new URL(targetUrl);
-              const key = url.pathname.substring(1);
+              const key = url.pathname.substring(1); // Remove leading slash
               if (key) query = `?r2Key=${encodeURIComponent(key)}`;
           } catch (e) {
               console.error("Failed to parse file URL for deletion:", e);
           }
       }
 
+      // Call the API to delete the message from the server
       api(`/api/messages/${message.id}${query}`, { method: 'DELETE' }).catch((error) => {
+        // If the API call fails, revert the change by re-adding the message
         console.error("Failed to delete message:", error);
         toast.error("Failed to delete message.");
         addOptimisticMessage(message.conversationId, message);
@@ -161,97 +174,82 @@ const MessageItem = ({ message, isGroup, participants, isHighlighted, onImageCli
     );
   }
 
-  const reactToMessage = async (emoji: string) => {
-    if (!user) return;
-    const userReaction = message.reactions?.find(r => r.userId === user.id);
-    
-    if (userReaction?.emoji === emoji) {
-      removeLocalReaction(message.conversationId, message.id, userReaction.id);
-      try {
-        if ((userReaction as any).isMessage) {
-            await api(`/api/messages/${userReaction.id}`, { method: 'DELETE' });
-        } else {
-            await api(`/api/messages/reactions/${userReaction.id}`, { method: 'DELETE' });
-        }
-      } catch (e) {
-        console.error("Failed to remove reaction:", e);
-      }
-      return;
-    }
-
-    if (userReaction) {
-        removeLocalReaction(message.conversationId, message.id, userReaction.id);
-        const deletePromise = (userReaction as any).isMessage
-            ? api(`/api/messages/${userReaction.id}`, { method: 'DELETE' })
-            : api(`/api/messages/reactions/${userReaction.id}`, { method: 'DELETE' });
-        deletePromise.catch(console.error);
-    }
-
-    try {
-        await sendReaction(message.conversationId, message.id, emoji);
-    } catch (e) {
-        console.error("Failed to send reaction:", e);
-    }
-  };
-
-  const handleContextMenu = (e: React.MouseEvent | React.TouchEvent) => {
-    e.preventDefault();
-    openMenu(e, [
-      { label: 'Reply', icon: <FiCornerUpLeft />, onClick: () => setReplyingTo(message) },
-      { label: 'Copy Text', icon: <FiCopy />, onClick: () => navigator.clipboard.writeText(message.content || '') },
-      { label: 'Security Info', icon: <FiShield />, onClick: () => toast('End-to-End Encrypted via Signal Protocol', { icon: 'ðŸ”’' }) },
-      { label: 'Copy Message ID', icon: <FiInfo />, onClick: () => navigator.clipboard.writeText(message.id) },
-      ...(mine && !message.optimistic ? [{ label: 'Delete', icon: <FiTrash2 />, destructive: true, onClick: handleDelete }] : [])
-    ], [
-      { emoji: 'ðŸ‘', onClick: () => reactToMessage('ðŸ‘') },
-      { emoji: 'â¤ï¸', onClick: () => reactToMessage('â¤ï¸') },
-      { emoji: 'ðŸ˜‚', onClick: () => reactToMessage('ðŸ˜‚') },
-      { emoji: 'ðŸ˜®', onClick: () => reactToMessage('ðŸ˜®') },
-      { emoji: 'ðŸ˜¢', onClick: () => reactToMessage('ðŸ˜¢') },
-    ]);
-  };
-
   return (
-    <motion.div ref={ref} id={message.id} initial={{ opacity: 0, y: 10 }} animate={{ opacity: 1, y: 0 }} transition={{ duration: 0.3, ease: 'easeOut' }} className={clsx('group flex flex-col', isFirstInSequence ? 'mt-3' : 'mt-1', mine ? 'items-end' : 'items-start', isHighlighted && 'bg-accent/10 rounded-lg p-1 -mx-1')}>
-      <SwipeableItem 
-        leftAction={{ icon: <FiCornerUpLeft size={20} />, color: 'bg-blue-500/80', onAction: () => setReplyingTo(message) }}
-        rightAction={{ icon: <FiInfo size={20} />, color: 'bg-secondary/80', onAction: () => toast('Message ID: ' + message.id, { icon: 'â„¹ï¸' }) }}
-      >
-        <div onContextMenu={handleContextMenu} className={`flex items-end gap-2 w-full select-none ${mine ? 'flex-row-reverse justify-start' : 'flex-row justify-start'}`}>
-          {!mine && (
-            <div className="w-8 flex-shrink-0 mb-1 self-end">
-              {isLastInSequence && (
-                <img 
-                  src={toAbsoluteUrl(profile.avatarUrl) || `https://api.dicebear.com/8.x/initials/svg?seed=${profile.name}`} 
-                  alt="Avatar" 
-                  className="w-8 h-8 rounded-full bg-secondary object-cover shadow-sm cursor-pointer hover:scale-105 transition-transform pointer-events-auto" 
-                />
-              )}
-            </div>
+    <motion.div ref={ref} id={message.id} initial={{ opacity: 0, y: 10 }} animate={{ opacity: 1, y: 0 }} transition={{ duration: 0.3, ease: 'easeOut' }} className={clsx('group flex items-end gap-2', isFirstInSequence ? 'mt-3' : 'mt-1', mine ? 'justify-end' : 'justify-start', isHighlighted && 'bg-accent/10 rounded-lg p-1 -mx-1')}>
+      {!mine && (
+        <div className="w-8 flex-shrink-0 mb-1 self-end">
+          {isLastInSequence && (
+            <img 
+              src={toAbsoluteUrl(profile.avatarUrl) || `https://api.dicebear.com/8.x/initials/svg?seed=${profile.name}`} 
+              alt="Avatar" 
+              className="w-8 h-8 rounded-full bg-secondary object-cover shadow-sm cursor-pointer hover:scale-105 transition-transform" 
+              // Note: Avatar click handler is usually handled by parent or could be passed down. 
+              // For simplicity, we can leave it visual or add onClick if needed.
+            />
+          )}
+        </div>
+      )}
+      
+      <div className={`flex items-end gap-2 ${mine ? 'flex-row-reverse' : 'flex-row'}`}>
+        <div className={clsx("flex flex-col max-w-[85%] sm:max-w-[70%]", mine ? "items-end" : "items-start")}>
+          {!mine && isGroup && profile.name && isFirstInSequence && (
+            <p className="text-[10px] font-bold mb-1 ml-1 user-color-name cursor-pointer hover:underline uppercase tracking-wide" style={{ '--user-color': getUserColor(message.senderId) } as React.CSSProperties}>
+              {profile.name}
+            </p>
           )}
           
-          <div className={clsx("flex flex-col max-w-[85%] sm:max-w-[70%]", mine ? "items-end" : "items-start")}>
-            {!mine && isGroup && profile.name && isFirstInSequence && (
-              <p className="text-[10px] font-bold mb-1 ml-1 user-color-name cursor-pointer hover:underline uppercase tracking-wide pointer-events-auto" style={{ '--user-color': getUserColor(message.senderId) } as React.CSSProperties}>
-                {profile.name}
-              </p>
-            )}
-            
-            <div className="pointer-events-auto w-full">
-              <MessageBubble 
-                message={message} 
-                isOwn={mine} 
-                onImageClick={onImageClick}
-                isLastInSequence={isLastInSequence}
-              />
-            </div>
-            
-            <ReactionsDisplay reactions={message.reactions} />
-          </div>
+          <MessageBubble 
+            message={message} 
+            isOwn={mine} 
+            onImageClick={onImageClick}
+            isLastInSequence={isLastInSequence}
+          />
+          
+          <ReactionsDisplay reactions={message.reactions} />
+        </div>
+
+        {/* Dropdown Menu (Three dots / Actions) */}
+        <div className="opacity-0 group-hover:opacity-100 transition-opacity self-center mb-2">
+          <DropdownMenu.Root>
+            <DropdownMenu.Trigger asChild><button className="p-1.5 rounded-full hover:bg-secondary"><svg xmlns="http://www.w3.org/2000/svg" className="h-4 w-4 text-text-secondary" viewBox="0 0 20 20" fill="currentColor"><path d="M10 6a2 2 0 110-4 2 2 0 010 4zm0 12a2 2 0 110-4 2 2 0 010 4zm0-6a2 2 0 110-4 2 2 0 010 4z" /></svg></button></DropdownMenu.Trigger>
+            <DropdownMenu.Portal>
+              <DropdownMenu.Content 
+                sideOffset={5} 
+                align="center" 
+                className="
+                  z-50 min-w-[180px] p-2
+                  rounded-xl bg-bg-main
+                  shadow-[8px_8px_20px_rgba(0,0,0,0.15),-8px_-8px_20px_rgba(255,255,255,1)]
+                  dark:shadow-[8px_8px_20px_rgba(0,0,0,0.5),-8px_-8px_20px_rgba(255,255,255,0.05)]
+                  border border-white/40 dark:border-white/5
+                  border-b-white/10 dark:border-b-black/50
+                "
+              >
+                <DropdownMenu.Item onSelect={() => setReplyingTo(message)} className="group flex items-center gap-3 px-3 py-2.5 mb-1 rounded-lg text-sm font-bold text-text-secondary outline-none cursor-pointer transition-all duration-200 data-[highlighted]:text-accent data-[highlighted]:shadow-[inset_3px_3px_6px_rgba(0,0,0,0.1),inset_-3px_-3px_6px_rgba(255,255,255,0.8)] dark:data-[highlighted]:shadow-[inset_2px_2px_5px_rgba(0,0,0,0.5),inset_-2px_-2px_5px_rgba(255,255,255,0.05)]">
+                  <FiCornerUpLeft className="opacity-70 group-data-[highlighted]:scale-110 transition-transform" />
+                  <span>Reply</span>
+                </DropdownMenu.Item>
+                
+                <ReactionPopover message={message}>
+                  <div className="group flex items-center gap-3 px-3 py-2.5 mb-1 rounded-lg text-sm font-bold text-text-secondary outline-none cursor-pointer transition-all duration-200 hover:text-accent hover:shadow-[inset_3px_3px_6px_rgba(0,0,0,0.1),inset_-3px_-3px_6px_rgba(255,255,255,0.8)] dark:hover:shadow-[inset_2px_2px_5px_rgba(0,0,0,0.5),inset_-2px_-2px_5px_rgba(255,255,255,0.05)]">
+                    <svg xmlns="http://www.w3.org/2000/svg" className="h-4 w-4 opacity-70 group-hover:scale-110 transition-transform" viewBox="0 0 20 20" fill="currentColor"><path fillRule="evenodd" d="M10 18a8 8 0 100-16 8 8 0 000 16zM7 9a1 1 0 100-2 1 1 0 000 2zm7-1a1 1 0 11-2 0 1 1 0 012 0zm-.464 5.535a.75.75 0 01.028.022l.028.027a.75.75 0 01.027.028l.027.028a.75.75 0 01.022.028l.022.028a.75.75 0 01.016.023l.016.023a.75.75 0 01.01.016l.01.016c.004.005.007.01.01.015l.004.005a.75.75 0 01.005.004l.005.004a.75.75 0 01.002.002l.002.002a.75.75 0 010 .004c0 .001 0 .002 0 .002a.75.75 0 01-.004 0l-.002-.002a.75.75 0 01-.005-.004l-.005-.004a.75.75 0 01-.01-.015l-.01-.016a.75.75 0 01-.016-.023l-.016-.023a.75.T5 0 01-.022-.028l-.022-.028a.75.75 0 01-.027-.028l-.027-.028a.75.75 0 01-.028-.022l-.028-.027a.75.75 0 01-.022-.028l-.022-.028a.75.75 0 01-.016-.023l-.016-.023a.75.75 0 01-.01-.016l-.01-.016a.75.75 0 01-.005-.004l-.005-.004a.75.75 0 01-.002-.002l-.002-.002a.75.75 0 010-.004c.09.34.26.65.49.93a.75.75 0 01-1.06 1.06 5.25 5.25 0 00-1.5 3.75.75.75 0 01-1.5 0 6.75 6.75 0 011.94-4.71.75.75 0 011.06-1.06z" clipRule="evenodd" /></svg>
+                    <span>React</span>
+                  </div>
+                </ReactionPopover>
+
+                {mine && !message.optimistic && (
+                  <DropdownMenu.Item onSelect={handleDelete} className="group flex items-center gap-3 px-3 py-2.5 mb-1 rounded-lg text-sm font-bold text-destructive outline-none cursor-pointer transition-all duration-200 data-[highlighted]:text-destructive data-[highlighted]:shadow-[inset_3px_3px_6px_rgba(0,0,0,0.1),inset_-3px_-3px_6px_rgba(255,255,255,0.8)] dark:data-[highlighted]:shadow-[inset_2px_2px_5px_rgba(0,0,0,0.5),inset_-2px_-2px_5px_rgba(255,255,255,0.05)]">
+                    <FiTrash2 className="opacity-70 group-data-[highlighted]:scale-110 transition-transform" />
+                    <span>Delete</span>
+                  </DropdownMenu.Item>
+                )}
+              </DropdownMenu.Content>
+            </DropdownMenu.Portal>
+          </DropdownMenu.Root>
         </div>
-      </SwipeableItem>
+      </div>
     </motion.div>
   );
 };
 
-export default memo(MessageItem);
+export default memo(MessageItem);
\ No newline at end of file
diff --git a/web/src/components/StartNewChat.tsx b/web/src/components/StartNewChat.tsx
index ad658f72..5860de4b 100644
--- a/web/src/components/StartNewChat.tsx
+++ b/web/src/components/StartNewChat.tsx
@@ -5,14 +5,7 @@ import toast from 'react-hot-toast';
 import { useUserProfile } from '@hooks/useUserProfile';
 import { toAbsoluteUrl } from '@utils/url';
 
-export interface SearchUser {
-  id: string;
-  encryptedProfile?: string | null;
-  isVerified?: boolean;
-  publicKey?: string;
-}
-
-function SearchResultItem({ u, loadingId, onStarted }: { u: SearchUser, loadingId: string | null, onStarted: (id: string) => void }) {
+function SearchResultItem({ u, loadingId, onStarted }: { u: any, loadingId: string | null, onStarted: (id: string) => void }) {
   const profile = useUserProfile(u);
   return (
     <button 
@@ -30,7 +23,7 @@ function SearchResultItem({ u, loadingId, onStarted }: { u: SearchUser, loadingI
 }
 
 export default function StartNewChat({ query, onStarted }: { query: string; onStarted: (id: string) => void }) {
-  const [list, setList] = useState<SearchUser[]>([]);
+  const [list, setList] = useState<{ id: string; encryptedProfile?: string | null; isVerified?: boolean; publicKey?: string }[]>([]);
   const [loadingId, setLoadingId] = useState<string | null>(null);
   const { searchUsers, startConversation } = useConversationStore(state => ({
     searchUsers: state.searchUsers,
diff --git a/web/src/components/SwipeableItem.tsx b/web/src/components/SwipeableItem.tsx
deleted file mode 100644
index 6af5a02e..00000000
--- a/web/src/components/SwipeableItem.tsx
+++ /dev/null
@@ -1,128 +0,0 @@
-import React, { useRef, useState, useEffect } from 'react';
-import { motion, useMotionValue, useTransform, useAnimation, PanInfo } from 'framer-motion';
-
-export interface SwipeAction {
-  icon: React.ReactNode;
-  color: string;
-  onAction: () => void;
-  threshold?: number;
-}
-
-interface SwipeableItemProps {
-  children: React.ReactNode;
-  leftAction?: SwipeAction; // Revealed when swiping RIGHT (pulling from left)
-  rightAction?: SwipeAction; // Revealed when swiping LEFT (pulling from right)
-  disableSwipe?: boolean;
-}
-
-export default function SwipeableItem({ children, leftAction, rightAction, disableSwipe = false }: SwipeableItemProps) {
-  const x = useMotionValue(0);
-  const controls = useAnimation();
-  const [triggered, setTriggered] = useState<"left" | "right" | null>(null);
-
-  // Background colors
-  const bgLeft = leftAction?.color || 'bg-blue-500';
-  const bgRight = rightAction?.color || 'bg-red-500';
-
-  // Transform constraints and visuals
-  const leftThreshold = leftAction?.threshold || 80;
-  const rightThreshold = rightAction?.threshold || -80;
-
-  // Scale icons based on swipe distance
-  const leftIconScale = useTransform(x, [0, leftThreshold], [0.5, 1]);
-  const rightIconScale = useTransform(x, [0, rightThreshold], [0.5, 1]);
-
-  // Opacity for background
-  const leftBgOpacity = useTransform(x, [0, leftThreshold / 2, leftThreshold], [0, 0.5, 1]);
-  const rightBgOpacity = useTransform(x, [0, rightThreshold / 2, rightThreshold], [0, 0.5, 1]);
-
-  // Haptic feedback state to avoid triggering multiple times
-  const hapticRef = useRef({ left: false, right: false });
-
-  useEffect(() => {
-    return x.on('change', (latest) => {
-      // Haptic for Left Action (Swiping Right)
-      if (leftAction && latest >= leftThreshold) {
-        if (!hapticRef.current.left) {
-          if (navigator.vibrate) navigator.vibrate(50);
-          hapticRef.current.left = true;
-          setTriggered("left");
-        }
-      } else {
-        hapticRef.current.left = false;
-        if (latest > 0) setTriggered(null);
-      }
-
-      // Haptic for Right Action (Swiping Left)
-      if (rightAction && latest <= rightThreshold) {
-        if (!hapticRef.current.right) {
-          if (navigator.vibrate) navigator.vibrate(50);
-          hapticRef.current.right = true;
-          setTriggered("right");
-        }
-      } else {
-        hapticRef.current.right = false;
-        if (latest < 0) setTriggered(null);
-      }
-    });
-  }, [x, leftAction, rightAction, leftThreshold, rightThreshold]);
-
-  const handleDragEnd = async (e: MouseEvent | TouchEvent | PointerEvent, info: PanInfo) => {
-    if (disableSwipe) return;
-
-    if (leftAction && info.offset.x >= leftThreshold) {
-      if (navigator.vibrate) navigator.vibrate(100);
-      leftAction.onAction();
-    } else if (rightAction && info.offset.x <= rightThreshold) {
-      if (navigator.vibrate) navigator.vibrate(100);
-      rightAction.onAction();
-    }
-
-    // Always bounce back
-    setTriggered(null);
-    controls.start({ x: 0, transition: { type: 'spring', stiffness: 400, damping: 30 } });
-  };
-
-  return (
-    <div className="relative w-full overflow-hidden rounded-2xl touch-pan-y">
-      {/* Background Actions */}
-      <div className="absolute inset-0 flex items-center justify-between px-4 pointer-events-none rounded-2xl">
-        {leftAction && (
-          <motion.div 
-            className={`absolute inset-y-0 left-0 flex items-center pl-6 pr-12 rounded-l-2xl ${bgLeft} text-white`}
-            style={{ opacity: leftBgOpacity, clipPath: 'inset(0)' }}
-          >
-            <motion.div style={{ scale: leftIconScale }} className={triggered === "left" ? "scale-125 transition-transform" : ""}>
-              {leftAction.icon}
-            </motion.div>
-          </motion.div>
-        )}
-        
-        {rightAction && (
-          <motion.div 
-            className={`absolute inset-y-0 right-0 flex items-center pr-6 pl-12 rounded-r-2xl justify-end ${bgRight} text-white`}
-            style={{ opacity: rightBgOpacity, clipPath: 'inset(0)' }}
-          >
-            <motion.div style={{ scale: rightIconScale }} className={triggered === "right" ? "scale-125 transition-transform" : ""}>
-              {rightAction.icon}
-            </motion.div>
-          </motion.div>
-        )}
-      </div>
-
-      {/* Foreground Swipeable Content */}
-      <motion.div
-        drag={disableSwipe ? false : "x"}
-        dragConstraints={{ left: 0, right: 0 }}
-        dragElastic={0.2}
-        dragDirectionLock={true}
-        onDragEnd={handleDragEnd}
-        animate={controls}
-        style={{ x }}
-        className="relative z-10 w-full"
-      >
-        {children}
-      </motion.div>
-    </div>
-  );
-}
diff --git a/web/src/hooks/useUserProfile.ts b/web/src/hooks/useUserProfile.ts
index 94f2ad22..856cc283 100644
--- a/web/src/hooks/useUserProfile.ts
+++ b/web/src/hooks/useUserProfile.ts
@@ -13,32 +13,23 @@ export function useUserProfile(user?: { id: string; encryptedProfile?: string |
   });
 
   useEffect(() => {
-    if (!user) {
-      setProfile({ name: "Unknown", avatarUrl: null, description: null });
-      return;
-    }
+    if (!user) return;
     
     let isMounted = true;
 
     const loadProfile = async () => {
-        // Generate composite cache key
-        const cacheKey = user.encryptedProfile ? `${user.id}_${user.encryptedProfile.substring(0, 32)}` : user.id;
-
         // Jika sudah ada di memori RAM, langsung pakai
-        if (profiles[cacheKey]) {
-            if (isMounted) setProfile(profiles[cacheKey]);
+        if (profiles[user.id]) {
+            setProfile(profiles[user.id]);
             return;
         }
 
-        // Clear stale profile state before starting async load
-        if (isMounted) setProfile({ name: "Encrypted User", avatarUrl: null, description: null });
-
         // Jika belum, suruh store decrypt (async) - INI AKAN MENGECEK IDB
         if (user.encryptedProfile) {
             const decrypted = await decryptAndCache(user.id, user.encryptedProfile);
             if (isMounted) setProfile(decrypted);
         } else {
-            if (isMounted) setProfile({ name: "Anonymous", avatarUrl: null, description: null }); // Jika user belum setup profil
+            if (isMounted) setProfile({ name: "Anonymous" }); // Jika user belum setup profil
         }
     };
 
diff --git a/web/src/lib/crypto-worker-proxy.ts b/web/src/lib/crypto-worker-proxy.ts
index 4874e6b5..b12ad86e 100644
--- a/web/src/lib/crypto-worker-proxy.ts
+++ b/web/src/lib/crypto-worker-proxy.ts
@@ -101,19 +101,19 @@ export async function restoreFromPhrase(phrase: string, password: string): Promi
 }
 
 export async function recoverAccountWithSignature(
-  phrase: string,
-  newPassword: string,
-  identifier: string,
-  timestamp: number,
-  nonce: string
+  phrase: string, 
+  newPassword: string, 
+  identifier: string, 
+  timestamp: number
 ): Promise<{
   encryptionPublicKeyB64: string,
   signingPublicKeyB64: string,
   encryptedPrivateKeys: string,
   signatureB64: string
 }> {
-  return sendToWorker('recoverAccountWithSignature', { phrase, newPassword, identifier, timestamp, nonce });
+  return sendToWorker('recoverAccountWithSignature', { phrase, newPassword, identifier, timestamp });
 }
+
 export async function encryptProfile(profileJsonString: string, profileKeyB64: string): Promise<string> {
   return sendToWorker('encryptProfile', { profileJsonString, profileKeyB64 });
 }
@@ -319,7 +319,7 @@ export function worker_dr_ratchet_decrypt(payload: {
     serializedState: SerializedRatchetState,
     header: any,
     ciphertext: Uint8Array
-}): Promise<{ state: SerializedRatchetState, plaintext: Uint8Array, skippedKeys: { dh: string, epk?: string, n: number, mk: string }[], mk: Uint8Array }> {
+}): Promise<{ state: SerializedRatchetState, plaintext: Uint8Array, skippedKeys: { dh: string, n: number, mk: string }[], mk: Uint8Array }> {
     return sendToWorker<{ state: SerializedRatchetState, plaintext: any, skippedKeys: any[], mk: any }>('dr_ratchet_decrypt', {
         serializedState: payload.serializedState,
         header: payload.header,
diff --git a/web/src/lib/keyStorage.ts b/web/src/lib/keyStorage.ts
index 2276521e..57d54fd0 100644
--- a/web/src/lib/keyStorage.ts
+++ b/web/src/lib/keyStorage.ts
@@ -33,40 +33,11 @@ export const getEncryptedKeys = async (): Promise<string | undefined> => {
 };
 
 /**
- * Generates or retrieves a device-bound non-extractable storage key.
+ * Menyimpan kunci auto-unlock perangkat ke IndexedDB
  */
-const getOrCreateDeviceStorageKey = async (): Promise<CryptoKey> => {
-  let key = await get<CryptoKey>('nyx_device_storage_key');
-  if (!key) {
-    key = await crypto.subtle.generateKey(
-      { name: 'AES-GCM', length: 256 },
-      false, // non-extractable!
-      ['encrypt', 'decrypt']
-    );
-    await set('nyx_device_storage_key', key);
-  }
-  return key;
-};
-
-/**
- * Menyimpan kunci auto-unlock perangkat ke IndexedDB (Encrypted)
- */
-export const saveDeviceAutoUnlockKey = async (password: string) => {
+export const saveDeviceAutoUnlockKey = async (key: string) => {
   try {
-    const key = await getOrCreateDeviceStorageKey();
-    const iv = crypto.getRandomValues(new Uint8Array(12));
-    const enc = new TextEncoder();
-    const encrypted = await crypto.subtle.encrypt(
-      { name: 'AES-GCM', iv },
-      key,
-      enc.encode(password)
-    );
-    
-    const payload = {
-      iv: Array.from(iv),
-      data: Array.from(new Uint8Array(encrypted))
-    };
-    await set(STORAGE_KEYS.DEVICE_AUTO_UNLOCK_KEY, JSON.stringify(payload));
+    await set(STORAGE_KEYS.DEVICE_AUTO_UNLOCK_KEY, key);
   } catch (error) {
     console.error('Failed to save device auto unlock key to IndexedDB:', error);
     throw new Error('Storage failure');
@@ -78,24 +49,7 @@ export const saveDeviceAutoUnlockKey = async (password: string) => {
  */
 export const getDeviceAutoUnlockKey = async (): Promise<string | undefined> => {
   try {
-    const payloadStr = await get<string>(STORAGE_KEYS.DEVICE_AUTO_UNLOCK_KEY);
-    if (!payloadStr) return undefined;
-    
-    // Fallback for legacy plaintext passwords
-    if (!payloadStr.startsWith('{')) {
-      return payloadStr; 
-    }
-    
-    const payload = JSON.parse(payloadStr);
-    const key = await getOrCreateDeviceStorageKey();
-    
-    const decrypted = await crypto.subtle.decrypt(
-      { name: 'AES-GCM', iv: new Uint8Array(payload.iv) },
-      key,
-      new Uint8Array(payload.data)
-    );
-    
-    return new TextDecoder().decode(decrypted);
+    return await get<string>(STORAGE_KEYS.DEVICE_AUTO_UNLOCK_KEY);
   } catch (error) {
     console.error('Failed to retrieve device auto unlock key from IndexedDB:', error);
     return undefined;
diff --git a/web/src/lib/keychainDb.ts b/web/src/lib/keychainDb.ts
index 32a3c7c6..e6fb7193 100644
--- a/web/src/lib/keychainDb.ts
+++ b/web/src/lib/keychainDb.ts
@@ -360,11 +360,6 @@ export async function clearAllKeys(): Promise<void> {
   await tx.done;
 }
 
-export interface VaultEntry {
-  key: any;
-  value: any;
-}
-
 /**
  * Mengekspor seluruh isi brankas kunci menjadi string JSON.
  * Aman karena setiap nilainya sudah terenkripsi oleh Master Seed.
@@ -374,18 +369,17 @@ export async function exportDatabaseToJson(): Promise<string> {
   const stores = [
     SESSION_KEYS_STORE_NAME, GROUP_KEYS_STORE_NAME, OTPK_STORE_NAME, 
     PENDING_HEADERS_STORE_NAME, RATCHET_SESSIONS_STORE_NAME, 
-    SKIPPED_KEYS_STORE_NAME, MESSAGE_KEYS_STORE_NAME, PROFILE_KEYS_STORE_NAME,
-    GROUP_SENDER_STATES_STORE, GROUP_RECEIVER_STATES_STORE
+    SKIPPED_KEYS_STORE_NAME, MESSAGE_KEYS_STORE_NAME, PROFILE_KEYS_STORE_NAME
   ];
   
-  const exportData: Record<string, VaultEntry[]> = {};
+  const exportData: Record<string, any[]> = {};
 
   for (const storeName of stores) {
     if (!db.objectStoreNames.contains(storeName)) continue;
     
     const tx = db.transaction(storeName, 'readonly');
     const store = tx.objectStore(storeName);
-    const items: VaultEntry[] = [];
+    const items = [];
     let cursor = await store.openCursor();
     while (cursor) {
       items.push({ key: cursor.key, value: cursor.value });
@@ -402,7 +396,7 @@ export async function exportDatabaseToJson(): Promise<string> {
  */
 export async function importDatabaseFromJson(jsonString: string): Promise<void> {
   const db = await getDb();
-  let importData: Record<string, VaultEntry[]>;
+  let importData;
   try {
       importData = JSON.parse(jsonString);
   } catch (e) {
@@ -412,17 +406,16 @@ export async function importDatabaseFromJson(jsonString: string): Promise<void>
   const stores = [
     SESSION_KEYS_STORE_NAME, GROUP_KEYS_STORE_NAME, OTPK_STORE_NAME, 
     PENDING_HEADERS_STORE_NAME, RATCHET_SESSIONS_STORE_NAME, 
-    SKIPPED_KEYS_STORE_NAME, MESSAGE_KEYS_STORE_NAME, PROFILE_KEYS_STORE_NAME,
-    GROUP_SENDER_STATES_STORE, GROUP_RECEIVER_STATES_STORE
+    SKIPPED_KEYS_STORE_NAME, MESSAGE_KEYS_STORE_NAME, PROFILE_KEYS_STORE_NAME
   ];
   
   const availableStores = stores.filter(s => db.objectStoreNames.contains(s));
   const tx = db.transaction(availableStores, 'readwrite');
   
   for (const storeName of availableStores) {
-    const store = tx.objectStore(storeName);
-    await store.clear(); // Selalu bersihkan brankas lama, bahkan jika importData[storeName] tidak ada
     if (importData[storeName]) {
+      const store = tx.objectStore(storeName);
+      await store.clear(); // Bersihkan brankas lama
       for (const item of importData[storeName]) {
         await store.put(item.value, item.key);
       }
diff --git a/web/src/pages/MigrationReceivePage.tsx b/web/src/pages/MigrationReceivePage.tsx
index 0e5e74dd..ed8f34c2 100644
--- a/web/src/pages/MigrationReceivePage.tsx
+++ b/web/src/pages/MigrationReceivePage.tsx
@@ -17,16 +17,11 @@ export default function MigrationReceivePage() {
   
   const keysRef = useRef<{ publicKey: Uint8Array, privateKey: Uint8Array } | null>(null);
   const chunksRef = useRef<ArrayBuffer[]>([]);
-  const metaRef = useRef<{ roomId: string, totalChunks: number, sealedKey: string, iv: string } | null>(null);
-  const migrationStartedRef = useRef(false);
+  const metaRef = useRef<{ totalChunks: number, sealedKey: string, iv: string } | null>(null);
 
   useEffect(() => {
-    let isMounted = true;
-    
     const init = async () => {
       const sodium = await getSodium();
-      if (!isMounted) return;
-      
       const keypair = sodium.crypto_box_keypair();
       keysRef.current = keypair;
       
@@ -43,7 +38,6 @@ export default function MigrationReceivePage() {
       socket.on('migration:start', (data) => {
         metaRef.current = data;
         chunksRef.current = new Array(data.totalChunks);
-        migrationStartedRef.current = false;
         setStatus('receiving');
         toast.loading('Connection established. Receiving data...', { id: 'mig' });
       });
@@ -54,8 +48,7 @@ export default function MigrationReceivePage() {
         const total = metaRef.current?.totalChunks || 1;
         setProgress(Math.round((receivedCount / total) * 100));
 
-        if (receivedCount === total && !migrationStartedRef.current) {
-          migrationStartedRef.current = true;
+        if (receivedCount === total) {
           setStatus('decrypting');
           toast.loading('Data received. Decrypting vault...', { id: 'mig' });
           await processMigration(sodium);
@@ -65,7 +58,6 @@ export default function MigrationReceivePage() {
     init();
     
     return () => {
-      isMounted = false;
       const socket = getSocket();
       socket.off('migration:start');
       socket.off('migration:chunk');
@@ -102,23 +94,13 @@ export default function MigrationReceivePage() {
       // 5. Import to IDB
       await importDatabaseFromJson(jsonString);
       
-      const socket = getSocket();
-      socket.emit('migration:ack', { roomId: metaRef.current!.roomId, success: true });
-
       setStatus('success');
       toast.success('Migration Complete! Welcome back.', { id: 'mig' });
       setTimeout(() => window.location.href = '/', 2000); // Hard reload to clear RAM
     } catch (e) {
       console.error(e);
       toast.error('Decryption failed. Data might be corrupted.', { id: 'mig' });
-      
-      const socket = getSocket();
-      if (metaRef.current?.roomId) {
-         socket.emit('migration:ack', { roomId: metaRef.current.roomId, success: false });
-      }
-
       setStatus('waiting');
-      migrationStartedRef.current = false;
     }
   };
 
diff --git a/web/src/pages/MigrationSendPage.tsx b/web/src/pages/MigrationSendPage.tsx
index ba216dcc..a9b14473 100644
--- a/web/src/pages/MigrationSendPage.tsx
+++ b/web/src/pages/MigrationSendPage.tsx
@@ -86,7 +86,6 @@ export default function MigrationSendPage() {
       const socket = getSocket();
       const totalChunks = Math.ceil(encryptedData.byteLength / CHUNK_SIZE);
       
-      socket.emit('migration:join', roomId);
       socket.emit('migration:start', { roomId, totalChunks, sealedKey, iv: ivB64 });
 
       for (let i = 0; i < totalChunks; i++) {
@@ -101,30 +100,13 @@ export default function MigrationSendPage() {
         await new Promise(r => setTimeout(r, 50));
       }
 
-      toast.loading('Waiting for receiver to process...', { id: 'send' });
-
-      // Wait for ACK
-      const ackResult = await new Promise((resolve) => {
-        const timeout = setTimeout(() => resolve(false), 30000); // 30s timeout
-        socket.once('migration:ack', (data: { roomId: string, success: boolean }) => {
-           if (data.roomId === roomId) {
-               clearTimeout(timeout);
-               resolve(data.success);
-           }
-        });
-      });
-
-      if (ackResult) {
-        setStatus('success');
-        toast.success('Transfer Complete!', { id: 'send' });
-        setTimeout(() => navigate('/settings'), 2000);
-      } else {
-        throw new Error("Receiver failed to decrypt or timed out");
-      }
+      setStatus('success');
+      toast.success('Transfer Complete!', { id: 'send' });
+      setTimeout(() => navigate('/settings'), 2000);
 
     } catch (e) {
       console.error(e);
-      toast.error('Migration failed. Invalid QR, Network error, or Timeout.', { id: 'send' });
+      toast.error('Migration failed. Invalid QR or Network error.', { id: 'send' });
       setStatus('scanning');
     }
   };
diff --git a/web/src/pages/Restore.tsx b/web/src/pages/Restore.tsx
index f1c5199c..ae45cab6 100644
--- a/web/src/pages/Restore.tsx
+++ b/web/src/pages/Restore.tsx
@@ -25,22 +25,18 @@ export default function RestorePage() {
     try {
       const trimmedPhrase = phrase.trim().toLowerCase();
       const timestamp = Date.now();
-
-      // 1. Fetch Server-side Nonce Challenge
-      const challengeRes = await api<{ nonce: string }>(`/api/auth/recover/challenge?identifier=${encodeURIComponent(identifier)}`, { method: 'GET' });
-      const nonce = challengeRes.nonce;
-
-      // 2. Generate keys & Sign Payload locally
+      
+      // 1. Generate keys & Sign Payload locally
       const {
         encryptedPrivateKeys,
         signatureB64
-      } = await recoverAccountWithSignature(trimmedPhrase, password, identifier, timestamp, nonce);
+      } = await recoverAccountWithSignature(trimmedPhrase, password, identifier, timestamp);
 
       if (!encryptedPrivateKeys || !signatureB64) {
         throw new Error("Failed to generate recovery payload.");
       }
 
-      // 3. Send Cryptographic Proof to Server
+      // 2. Send Cryptographic Proof to Server
       const res = await api<{ accessToken: string }>('/api/auth/recover', {
         method: 'POST',
         body: JSON.stringify({
@@ -48,10 +44,10 @@ export default function RestorePage() {
           newPassword: password,
           newEncryptedKeys: encryptedPrivateKeys,
           signature: signatureB64,
-          timestamp,
-          nonce
+          timestamp
         })
       });
+
       // 3. Save to local storage & finalize login
       await saveEncryptedKeys(encryptedPrivateKeys);
       useAuthStore.getState().setHasRestoredKeys(true);
@@ -66,7 +62,7 @@ export default function RestorePage() {
       // Actually, api/auth/recover returns accessToken. We should set it.
       if (res.accessToken) {
           useAuthStore.getState().setAccessToken(res.accessToken);
-          await useAuthStore.getState().bootstrap(true); // Force fetch user profile
+          await useAuthStore.getState().bootstrap(); // This fetches user profile
       }
 
       toast.success('Account successfully recovered! Welcome back.');
diff --git a/web/src/pages/SettingsPage.tsx b/web/src/pages/SettingsPage.tsx
index 10c811a5..baaefbe1 100644
--- a/web/src/pages/SettingsPage.tsx
+++ b/web/src/pages/SettingsPage.tsx
@@ -220,7 +220,7 @@ export default function SettingsPage() {
     e.preventDefault();
     setIsLoading(true);
     try {
-      let currentAvatarUrl = profile?.avatarUrl;
+      let currentAvatarUrl = profile.avatarUrl;
 
       if (avatarFile) {
         currentAvatarUrl = await updateAvatar(avatarFile);
@@ -445,7 +445,7 @@ export default function SettingsPage() {
                     bg-bg-main p-2
                   ">
                     <img
-                      src={previewUrl || `https://api.dicebear.com/8.x/initials/svg?seed=${profile?.name || 'Anonymous'}`}
+                      src={previewUrl || `https://api.dicebear.com/8.x/initials/svg?seed=${profile.name}`}
                       alt="ID"
                       className="w-full h-full rounded-full object-cover grayscale group-hover:grayscale-0 transition-all duration-500"
                     />
diff --git a/web/src/store/auth.ts b/web/src/store/auth.ts
index 57af91e5..275905e1 100644
--- a/web/src/store/auth.ts
+++ b/web/src/store/auth.ts
@@ -76,7 +76,7 @@ type RegisterResponse = {
 };
 
 type Actions = {
-  bootstrap: (force?: boolean) => Promise<void>;
+  bootstrap: () => Promise<void>;
   tryAutoUnlock: () => Promise<boolean>;
   login: (usernameHash: string, password: string, restoredNotSynced?: boolean) => Promise<void>;
   registerAndGeneratePhrase: (data: { 
@@ -217,9 +217,8 @@ export const useAuthStore = createWithEqualityFn<State & Actions>((set, get) =>
       await setDeviceAutoUnlockReady(true);
     },
 
-    bootstrap: async (force = false) => {
-      // If we already have a token and user profile, and we aren't forcing a refresh, return early.
-      if (!force && get().accessToken && get().user) {
+    bootstrap: async () => {
+      if (get().accessToken) {
         set({ isBootstrapping: false });
         return;
       }
@@ -323,7 +322,17 @@ export const useAuthStore = createWithEqualityFn<State & Actions>((set, get) =>
           phrase
         } = await registerAndGenerateKeys(password);
 
-        // API Call First
+        await saveEncryptedKeys(encryptedPrivateKeys);
+        await saveDeviceAutoUnlockKey(password);
+        await setDeviceAutoUnlockReady(true);
+        set({ hasRestoredKeys: true });
+
+        // Cache keys
+        try {
+          const result = await retrievePrivateKeys(encryptedPrivateKeys, password);
+          if (result.success) privateKeysCache = result.keys;
+        } catch (e) {}
+
         const res = await api<{ accessToken: string; user: User }>("/api/auth/register", {
           method: "POST",
           body: JSON.stringify({
@@ -337,18 +346,6 @@ export const useAuthStore = createWithEqualityFn<State & Actions>((set, get) =>
           }),
         });
 
-        // Only persist local vault state if the server registration succeeds
-        await saveEncryptedKeys(encryptedPrivateKeys);
-        await saveDeviceAutoUnlockKey(password);
-        await setDeviceAutoUnlockReady(true);
-        set({ hasRestoredKeys: true });
-
-        // Cache keys
-        try {
-          const result = await retrievePrivateKeys(encryptedPrivateKeys, password);
-          if (result.success) privateKeysCache = result.keys;
-        } catch (e) {}
-
         set({ user: res.user, accessToken: res.accessToken });
         localStorage.setItem("user", JSON.stringify(res.user));
         
diff --git a/web/src/store/contextMenu.ts b/web/src/store/contextMenu.ts
deleted file mode 100644
index 57b22175..00000000
--- a/web/src/store/contextMenu.ts
+++ /dev/null
@@ -1,53 +0,0 @@
-import { create } from 'zustand';
-import React from 'react';
-
-export interface ContextMenuOption {
-  label: string;
-  icon?: React.ReactNode;
-  onClick: () => void;
-  destructive?: boolean;
-}
-
-export interface ContextMenuState {
-  isOpen: boolean;
-  x: number;
-  y: number;
-  options: ContextMenuOption[];
-  reactions?: { emoji: string; onClick: () => void }[];
-  closeMenu: () => void;
-  openMenu: (
-    e: React.MouseEvent | React.TouchEvent | MouseEvent | TouchEvent,
-    options: ContextMenuOption[],
-    reactions?: { emoji: string; onClick: () => void }[]
-  ) => void;
-}
-
-export const useContextMenuStore = create<ContextMenuState>((set) => ({
-  isOpen: false,
-  x: 0,
-  y: 0,
-  options: [],
-  reactions: undefined,
-  closeMenu: () => set({ isOpen: false }),
-  openMenu: (e, options, reactions) => {
-    e.preventDefault();
-    let clientX = 0;
-    let clientY = 0;
-
-    if ('clientX' in e) {
-      clientX = e.clientX;
-      clientY = e.clientY;
-    } else if ('touches' in e && e.touches.length > 0) {
-      clientX = e.touches[0].clientX;
-      clientY = e.touches[0].clientY;
-    }
-
-    set({
-      isOpen: true,
-      x: clientX,
-      y: clientY,
-      options,
-      reactions,
-    });
-  },
-}));
diff --git a/web/src/store/message.ts b/web/src/store/message.ts
index 48b01057..6c442837 100644
--- a/web/src/store/message.ts
+++ b/web/src/store/message.ts
@@ -138,22 +138,20 @@ export async function decryptMessageObject(message: Message, seenIds = new Set<s
     }
 
     // [FIX] PREVENT RE-DECRYPTION LOOP
-    const isLikelyEncrypted = (str: string) => {
-        const trimmed = str.trim();
-        // 1. Check for JSON payload containing encryption markers
-        if (trimmed.startsWith('{') && (trimmed.includes('"header"') || trimmed.includes('"ciphertext"') || trimmed.includes('"dr"'))) {
-            return true;
-        }
-        // 2. Check for legacy/base64 encoded ciphertexts
-        // A valid base64 string shouldn't contain spaces and typically matches this regex
-        const base64Regex = /^[A-Za-z0-9+/]+={0,2}$/;
-        if (base64Regex.test(trimmed) && trimmed.length > 20) { // arbitrary min length for a real ciphertext
-            return true;
+    // If content doesn't look like JSON, it's likely already plaintext.
+    if (typeof contentToDecrypt === 'string' && !contentToDecrypt.trim().startsWith('{')) {
+        return decryptedMsg;
+    }
+    
+    // Check if it's a valid encryption payload (contains specific keys)
+    try {
+        if (contentToDecrypt.includes('"header"') || contentToDecrypt.includes('"ciphertext"') || contentToDecrypt.includes('"dr"')) {
+            // It looks like a payload, proceed to decrypt
+        } else {
+            // Probably just a JSON message (like file metadata) that is already decrypted
+            return decryptedMsg;
         }
-        return false;
-    };
-
-    if (!isLikelyEncrypted(contentToDecrypt)) {
+    } catch {
         return decryptedMsg;
     }
 
@@ -692,15 +690,6 @@ export const useMessageStore = createWithEqualityFn<State & Actions>((set, get)
         if (res.ok && res.msg) {
           await removeFromQueue(tempId);
           get().replaceOptimisticMessage(conversationId, tempId, { ...res.msg, status: 'SENT' });
-          
-          const msgId = res.msg.id;
-          import('@utils/crypto').then(async ({ retrieveMessageKeySecurely, storeMessageKeySecurely, deleteMessageKeySecurely }) => {
-              const mk = await retrieveMessageKeySecurely(`temp_${tempId}`);
-              if (mk) {
-                  await storeMessageKeySecurely(msgId, mk);
-                  await deleteMessageKeySecurely(`temp_${tempId}`);
-              }
-          }).catch(console.error);
         } else {
           console.error(`[Queue] Failed to send queued message ${tempId}:`, res.error);
           await updateQueueAttempt(tempId, attempt + 1);
diff --git a/web/src/store/profile.ts b/web/src/store/profile.ts
index ad55cce7..7064ad83 100644
--- a/web/src/store/profile.ts
+++ b/web/src/store/profile.ts
@@ -16,27 +16,24 @@ type ProfileState = {
 export const useProfileStore = createWithEqualityFn<ProfileState>((set, get) => ({
   profiles: {},
   decryptAndCache: async (userId, encryptedProfile) => {
-    // 1. Generate composite cache key to prevent stale data if profile changes
-    const cacheKey = encryptedProfile ? `${userId}_${encryptedProfile.substring(0, 32)}` : userId;
-
-    // 2. Return cache if exists
-    if (get().profiles[cacheKey]) return get().profiles[cacheKey];
+    // 1. Return cache if exists
+    if (get().profiles[userId]) return get().profiles[userId];
     
-    // 3. Default fallback
+    // 2. Default fallback
     const fallback: DecryptedProfile = { name: "Encrypted User" };
     if (!encryptedProfile) return fallback;
 
     try {
-      // 4. Cari ProfileKey di IndexedDB
+      // 3. Cari ProfileKey di IndexedDB
       const profileKey = await getProfileKey(userId);
       if (!profileKey) return fallback;
 
-      // 5. Decrypt via Worker
+      // 4. Decrypt via Worker
       const jsonString = await decryptProfile(encryptedProfile, profileKey);
       const parsed = JSON.parse(jsonString) as DecryptedProfile;
       
-      // 6. Save to RAM
-      set((state) => ({ profiles: { ...state.profiles, [cacheKey]: parsed } }));
+      // 5. Save to RAM
+      set((state) => ({ profiles: { ...state.profiles, [userId]: parsed } }));
       return parsed;
     } catch (e) {
       console.error(`Failed to decrypt profile for ${userId}`, e);
diff --git a/web/src/types/socket.d.ts b/web/src/types/socket.d.ts
index 8929c61b..58055baf 100644
--- a/web/src/types/socket.d.ts
+++ b/web/src/types/socket.d.ts
@@ -50,7 +50,6 @@ export interface ServerToClientEvents {
     // --- DEVICE MIGRATION TUNNEL (SERVER -> CLIENT) ---
     "migration:start": (payload: { roomId: string; totalChunks: number; sealedKey: string; iv: string }) => void;
     "migration:chunk": (payload: { roomId: string; chunkIndex: number; chunk: any }) => void;
-    "migration:ack": (payload: { roomId: string; success: boolean }) => void;
 }
 
 export interface ClientToServerEvents {
@@ -88,5 +87,4 @@ export interface ClientToServerEvents {
     "migration:join": (roomId: string) => void;
     "migration:start": (payload: { roomId: string; totalChunks: number; sealedKey: string; iv: string }) => void;
     "migration:chunk": (payload: { roomId: string; chunkIndex: number; chunk: any }) => void;
-    "migration:ack": (payload: { roomId: string; success: boolean }) => void;
 }
\ No newline at end of file
diff --git a/web/src/utils/crypto.ts b/web/src/utils/crypto.ts
index a7ad7fb2..4e4cef3c 100644
--- a/web/src/utils/crypto.ts
+++ b/web/src/utils/crypto.ts
@@ -335,12 +335,19 @@ export async function ensureGroupSession(conversationId: string, participants: P
 
       // 1. Generate NEW Sender Key (Chain Key)
       const { senderKeyB64 } = await groupInitSenderKey();
+      
+      // 2. Save Initial Sender State
+      await saveGroupSenderState({
+          conversationId,
+          CK: senderKeyB64,
+          N: 0
+      });
 
       const myId = useAuthStore.getState().user?.id;
       const otherParticipants = participants.filter(p => p.id !== myId);
       const missingKeys: string[] = [];
 
-      // 2. Encrypt Sender Key for EACH participant (Fan-out)
+      // 3. Encrypt Sender Key for EACH participant (Fan-out)
       const distributionKeys = await Promise.all(
         otherParticipants.map(async (p) => {
           if (!p.publicKey) {
@@ -361,13 +368,6 @@ export async function ensureGroupSession(conversationId: string, participants: P
         })
       );
 
-      // 3. Save Initial Sender State ONLY after successful encryption fan-out
-      await saveGroupSenderState({
-          conversationId,
-          CK: senderKeyB64,
-          N: 0
-      });
-
       return distributionKeys.filter(Boolean);
     } finally {
       groupSessionLocks.delete(conversationId);
@@ -472,20 +472,13 @@ async function requestGroupKeyWithTimeout(conversationId: string, attempt = 0) {
 
 const XCHACHA20_NONCE_BYTES = 24;
 
-export interface DrHeader {
-  dh: string;
-  pn: number;
-  n: number;
-  epk?: string;
-}
-
 export async function encryptMessage(
   text: string,
   conversationId: string,
   isGroup: boolean = false,
   existingSession?: { sessionId: string; key: Uint8Array },
   messageId?: string
-): Promise<{ ciphertext: string; sessionId?: string; drHeader?: DrHeader; mk?: Uint8Array }> {
+): Promise<{ ciphertext: string; sessionId?: string; drHeader?: any; mk?: Uint8Array }> {
   const sodium = await getSodiumLib();
   const { worker_crypto_secretbox_xchacha20poly1305_easy, worker_dr_ratchet_encrypt, groupRatchetEncrypt } = await getWorkerProxy();
 
@@ -610,7 +603,7 @@ export async function decryptMessage(
         const conversation = useConversationStore.getState().conversations.find(c => c.id === conversationId);
         const sender = conversation?.participants.find(p => p.id === senderId);
         
-        const keyToUse = sender?.signingKey;
+        const keyToUse = sender?.signingKey || sender?.publicKey;
         if (!keyToUse) {
              return { status: 'error', error: new Error('Missing sender signing key') };
         }
@@ -641,9 +634,9 @@ export async function decryptMessage(
         
         return { status: 'success', value: sodium.to_string(result.plaintext) };
         
-    } catch (e: unknown) {
+    } catch (e: any) {
       console.error(`Group Decryption failed for convo ${conversationId}:`, e);
-      return { status: 'error', error: e instanceof Error ? e : new Error('Failed to decrypt group message') };
+      return { status: 'error', error: new Error(e.message || 'Failed to decrypt group message') };
     }
   } else {
     // DOUBLE RATCHET & LEGACY FALLBACK
@@ -681,9 +674,7 @@ export async function decryptMessage(
 
       const drHeader = payload.dr;
       const actualCipher = payload.ciphertext;
-      // Prefer epk if present, otherwise fallback to dh
-      const dhKey = drHeader.epk || drHeader.dh;
-      const headerKey = `${conversationId}_${dhKey}_${drHeader.n}`;
+      const headerKey = `${conversationId}_${drHeader.dh}_${drHeader.n}`;
 
       const skippedMkStr = await retrieveSkippedMessageKeySecurely(headerKey);
       if (skippedMkStr) {
@@ -718,16 +709,15 @@ export async function decryptMessage(
       }
 
       for (const sk of result.skippedKeys) {
-          const skDhKey = sk.epk || sk.dh;
-          const hKey = `${conversationId}_${skDhKey}_${sk.n}`;
+          const hKey = `${conversationId}_${sk.dh}_${sk.n}`;
           await storeSkippedMessageKeySecurely(hKey, sk.mk);
       }
 
       return { status: 'success', value: sodium.to_string(result.plaintext) };
 
-    } catch (e: unknown) {
+    } catch (e: any) {
       console.error(`DR Decryption failed for convo ${conversationId}:`, e);
-      return { status: 'error', error: e instanceof Error ? e : new Error('Failed to decrypt message') };
+      return { status: 'error', error: new Error('Failed to decrypt message') };
     }
   }
 }
@@ -925,13 +915,9 @@ export async function storeReceivedSessionKey(payload: ReceiveKeyPayload): Promi
     
     // Use the NEW handler for Sender Key
     await handleGroupKeyDistribution(conversationId, encryptedKey, senderId);
-
-    // Trigger reprocessing of pending messages
-    import('@store/message').then(({ useMessageStore }) => {
-        useMessageStore.getState().reDecryptPendingMessages(conversationId);
-    });
-
-    } else if (sessionId) {    let newSessionKey: Uint8Array | undefined;
+    
+  } else if (sessionId) {
+    let newSessionKey: Uint8Array | undefined;
 
     if (encryptedKey.startsWith('{') && encryptedKey.includes('"x3dh":true')) {
         try {
@@ -953,17 +939,17 @@ export async function storeReceivedSessionKey(payload: ReceiveKeyPayload): Promi
             }
         } catch (e) {
             console.error("X3DH derivation failed, falling back to legacy decrypt:", e);
-            if (encryptedKey.length > 20 && !encryptedKey.trim().startsWith('{')) {
+            if (encryptedKey.length > 20) {
                 const { publicKey, privateKey } = await getMyEncryptionKeyPair();
                 newSessionKey = await decryptSessionKeyForUser(encryptedKey, publicKey, privateKey);
             } else {
-                console.warn("[Crypto] Skipping decryption for invalid/placeholder or JSON key.");
+                console.warn("[Crypto] Skipping decryption for invalid/placeholder key.");
                 return;
             }
         }
     } else {
-        if (!encryptedKey || encryptedKey.length < 20 || encryptedKey.trim().startsWith('{')) {
-             console.warn("[Crypto] Received empty, short, or JSON session key where base64 was expected. Ignoring.");
+        if (!encryptedKey || encryptedKey.length < 20) {
+             console.warn("[Crypto] Received empty or short session key. Ignoring placeholder.");
              return;
         }
 
diff --git a/web/src/workers/crypto.worker.ts b/web/src/workers/crypto.worker.ts
index ff1a2dd6..58088013 100644
--- a/web/src/workers/crypto.worker.ts
+++ b/web/src/workers/crypto.worker.ts
@@ -616,7 +616,7 @@ self.onmessage = async (event: MessageEvent) => {
         break;
       }
       case 'recoverAccountWithSignature': {
-        const { phrase, newPassword, identifier, timestamp, nonce } = payload;
+        const { phrase, newPassword, identifier, timestamp } = payload;
         const masterSeedHex = bip39.mnemonicToEntropy(phrase);
         const masterSeed = sodium.from_hex(masterSeedHex);
 
@@ -636,8 +636,8 @@ self.onmessage = async (event: MessageEvent) => {
             masterSeed: masterSeed
           }, newPassword);
 
-          // BUAT DIGITAL SIGNATURE (Full Payload with Nonce)
-          const messageString = `${identifier}:${timestamp}:${nonce}:${newPassword}:${encryptedPrivateKeys}`;
+          // BUAT DIGITAL SIGNATURE
+          const messageString = `${identifier}:${timestamp}`;
           const messageBytes = new TextEncoder().encode(messageString);
           const signature = sodium.crypto_sign_detached(messageBytes, signingKeyPair.privateKey);
 
@@ -1077,10 +1077,7 @@ self.onmessage = async (event: MessageEvent) => {
                       const [newCKr, mk] = await kdfChain(state.CKr);
                       sodium.memzero(state.CKr);
                       state.CKr = newCKr;
-                      // When storing skipped keys from a previous chain, state.DHr holds the previous public key.
-                      // At this point, we only know its DH value, we don't have its EPK context because we are moving PAST it.
-                      // The main logic in crypto.ts will use .epk || .dh, so if epk is undefined it just falls back to dh.
-                      skippedKeys.push({ dh: bytesToB64(state.DHr), n: state.Nr, mk: bytesToB64(mk), epk: header.epk });
+                      skippedKeys.push({ dh: bytesToB64(state.DHr), n: state.Nr, mk: bytesToB64(mk) });
                       state.Nr += 1;
                    }
                 }
@@ -1121,7 +1118,7 @@ self.onmessage = async (event: MessageEvent) => {
                 const [newCKr, mk] = await kdfChain(state.CKr);
                 sodium.memzero(state.CKr);
                 state.CKr = newCKr;
-                skippedKeys.push({ dh: bytesToB64(state.DHr), n: state.Nr, mk: bytesToB64(mk), epk: header.epk });
+                skippedKeys.push({ dh: bytesToB64(state.DHr), n: state.Nr, mk: bytesToB64(mk) });
                 state.Nr += 1;
             }
             
