diff --git a/web/src/lib/crypto-worker-proxy.ts b/web/src/lib/crypto-worker-proxy.ts
index 79592f7c..731b8c6a 100644
--- a/web/src/lib/crypto-worker-proxy.ts
+++ b/web/src/lib/crypto-worker-proxy.ts
@@ -341,14 +341,15 @@ export async function groupRatchetEncrypt(
   serializedState: { CK: string; N: number },
   plaintext: string | Uint8Array,
   signingPrivateKey: Uint8Array
-): Promise<{ state: { CK: string; N: number }, header: { n: number }, ciphertext: Uint8Array, signature: string }> {
-  return sendToWorker<{ state: { CK: string; N: number }, header: { n: number }, ciphertext: any, signature: string }>('group_ratchet_encrypt', { 
+): Promise<{ state: { CK: string; N: number }, header: { n: number }, ciphertext: Uint8Array, signature: string, mk: Uint8Array }> {
+  return sendToWorker<{ state: { CK: string; N: number }, header: { n: number }, ciphertext: any, signature: string, mk: any }>('group_ratchet_encrypt', { 
     serializedState, 
     plaintext: typeof plaintext === 'string' ? plaintext : Array.from(plaintext),
     signingPrivateKey: Array.from(signingPrivateKey) 
   }).then(res => ({
       ...res,
-      ciphertext: new Uint8Array(res.ciphertext)
+      ciphertext: new Uint8Array(res.ciphertext),
+      mk: new Uint8Array(res.mk)
   }));
 }
 
diff --git a/web/src/store/message.ts b/web/src/store/message.ts
index 4f83d17a..ccf106d5 100644
--- a/web/src/store/message.ts
+++ b/web/src/store/message.ts
@@ -24,7 +24,6 @@ import { useConversationStore } from "./conversation";
 import { addToQueue, getQueueItems, removeFromQueue, updateQueueAttempt } from "@lib/offlineQueueDb";
 import { useConnectionStore } from "./connection";
 import { getSodium } from "@lib/sodiumInitializer";
-// getPendingHeader removed as requested
 
 /**
  * Logika Dekripsi Terpusat (Single Source of Truth)
@@ -41,10 +40,30 @@ export async function decryptMessageObject(message: Message, seenIds = new Set<s
   }
   seenIds.add(decryptedMsg.id);
 
+  const conversation = useConversationStore.getState().conversations.find(c => c.id === decryptedMsg.conversationId);
+  const isGroup = conversation?.isGroup || false;
+
   try {
     // [FIX #1] SELF-MESSAGE DECRYPTION (Pesan Sendiri)
-    // Jika ini pesan saya sendiri, jangan pakai Ratchet! Ambil kunci dari brankas lokal.
+    // Jika ini pesan saya sendiri
     if (currentUser && decryptedMsg.senderId === currentUser.id) {
+        // A. Jika Grup: Kita tidak bisa mendekripsi pesan sendiri via Ratchet Receiver karena kita tidak punya Receiver State untuk diri sendiri.
+        if (isGroup) {
+            // Jika konten masih ciphertext (belum didekripsi optimis)
+            if (decryptedMsg.content && decryptedMsg.content.startsWith('{') && decryptedMsg.content.includes('"ciphertext"')) {
+                 // Coba cek apakah ini pesan optimis yang baru saja dikirim?
+                 // Biasanya pesan optimis sudah plaintext. Jika masuk sini, berarti ini pesan dari fetch history (reload).
+                 // Tanpa penyimpanan MK lokal khusus grup, kita tidak bisa mendekripsinya.
+                 
+                 // Fallback UX:
+                 decryptedMsg.content = "ðŸ”’ You sent this message (Encrypted)";
+                 // Idealnya: Kita simpan MK lokal saat kirim, lalu coba retrieveMessageKeySecurely di sini.
+                 // Tapi sesuai instruksi, kita handle gracefully.
+            }
+            return decryptedMsg;
+        }
+
+        // B. Jika 1-on-1: Coba ambil Message Key dari brankas lokal (MK Vault)
         const { retrieveMessageKeySecurely } = await import('@utils/crypto');
         const mk = await retrieveMessageKeySecurely(decryptedMsg.id);
         
@@ -62,11 +81,9 @@ export async function decryptMessageObject(message: Message, seenIds = new Set<s
                     if (parsed.ciphertext) {
                         cipherTextToUse = parsed.ciphertext;
                     } else {
-                        // Found a JSON object but no 'ciphertext' property? Stop peeling.
                         break;
                     }
                 } catch {
-                    // Not valid JSON, stop peeling.
                     break;
                 }
             }
@@ -92,10 +109,9 @@ export async function decryptMessageObject(message: Message, seenIds = new Set<s
                         }
                     } catch (e) {}
                 }
-                // --------------------------------------------
                 
                 decryptedMsg.content = plainText;
-                // Handle blind attachment if needed
+                
                 if (decryptedMsg.content && decryptedMsg.content.startsWith('{') && decryptedMsg.content.includes('"type":"file"')) {
                     try {
                         const metadata = JSON.parse(decryptedMsg.content);
@@ -115,9 +131,6 @@ export async function decryptMessageObject(message: Message, seenIds = new Set<s
         }
     }
 
-    const conversation = useConversationStore.getState().conversations.find(c => c.id === decryptedMsg.conversationId);
-    const isGroup = conversation?.isGroup || false;
-
     // 2. Tentukan Payload yang Akan Didekripsi
     let contentToDecrypt = decryptedMsg.ciphertext;
 
@@ -134,7 +147,7 @@ export async function decryptMessageObject(message: Message, seenIds = new Set<s
     }
 
     // -------------------------------------------------------------------------
-    // FLOW BARU: X3DH HEADER DETECTION (RECEIVING)
+    // FLOW BARU: X3DH HEADER DETECTION (RECEIVING - 1on1 Only)
     // -------------------------------------------------------------------------
     if (!isGroup && contentToDecrypt.startsWith('{') && contentToDecrypt.includes('"x3dh":')) {
        try {
@@ -143,14 +156,11 @@ export async function decryptMessageObject(message: Message, seenIds = new Set<s
            const mk = await retrieveMessageKeySecurely(message.id);
            
            if (mk) {
-               // We already processed this message in the past! Skip X3DH derivation entirely.
                contentToDecrypt = payload.ciphertext;
            } else if (payload.x3dh && payload.ciphertext) {
-               // Normal X3DH derivation
                const { ik, ek, otpkId } = payload.x3dh;
                const ciphertext = payload.ciphertext;
 
-               // Derive Key
                const myIdentityKeyPair = await getMyEncryptionKeyPair();
                const { getSignedPreKeyPair } = useAuthStore.getState();
                const mySignedPreKeyPair = await getSignedPreKeyPair();
@@ -163,8 +173,6 @@ export async function decryptMessageObject(message: Message, seenIds = new Set<s
                    otpkId
                );
 
-               // [DOUBLE RATCHET INIT BOB]
-               // We MUST extract Alice's Ratchet Public Key (dr.dh / epk) from the inner payload first!
                let theirRatchetPublicKey: Uint8Array | undefined;
                
                try {
@@ -190,11 +198,10 @@ export async function decryptMessageObject(message: Message, seenIds = new Set<s
                });
 
                await storeRatchetStateSecurely(message.conversationId, newState);
-               contentToDecrypt = ciphertext; // Update target content
+               contentToDecrypt = ciphertext; 
            }
        } catch (e) {
            console.error("[X3DH] Failed to parse/derive from header:", e);
-           // Fallback to treat as normal ciphertext if parsing fails
        }
     }
 
@@ -206,24 +213,26 @@ export async function decryptMessageObject(message: Message, seenIds = new Set<s
     let attempts = 0;
     const MAX_ATTEMPTS = options.skipRetries ? 1 : 3;
 
+    // [PHASE 3 FIX] Correct Session ID / Sender ID mapping
+    const sessionOrSenderId = isGroup ? decryptedMsg.senderId : decryptedMsg.sessionId;
+
     while (attempts < MAX_ATTEMPTS) {
         result = await decryptMessage(
-          contentToDecrypt!, // Non-null assertion guarded by check above
+          contentToDecrypt!, 
           decryptedMsg.conversationId,
           isGroup,
-          decryptedMsg.sessionId,
+          sessionOrSenderId, // Updated Argument
           decryptedMsg.id
         );
 
         if (result.status === 'success' || result.status === 'error') {
-            break; // Selesai atau error fatal
+            break; 
         }
 
-        // Jika pending, tunggu sebentar siapa tau kuncinya sedang diproses/disimpan
         if (result.status === 'pending') {
             attempts++;
             if (attempts < MAX_ATTEMPTS) {
-                await new Promise(r => setTimeout(r, 800)); // Tunggu 800ms
+                await new Promise(r => setTimeout(r, 800)); 
             }
         }
     }
@@ -232,7 +241,7 @@ export async function decryptMessageObject(message: Message, seenIds = new Set<s
     if (result?.status === 'success') {
       let plainText = result.value;
 
-      // --- EKSTRAKSI PROFILE KEY DARI PENERIMA ---
+      // --- EKSTRAKSI PROFILE KEY ---
       if (plainText && plainText.trim().startsWith('{')) {
           try {
               const parsed = JSON.parse(plainText);
@@ -241,8 +250,6 @@ export async function decryptMessageObject(message: Message, seenIds = new Set<s
                   const { useProfileStore } = await import('@store/profile');
                   
                   await saveProfileKey(decryptedMsg.senderId, parsed.profileKey);
-                  
-                  // Trigger cache update immediately
                   useProfileStore.getState().decryptAndCache(decryptedMsg.senderId, decryptedMsg.sender?.encryptedProfile || null);
                   
                   delete parsed.profileKey;
@@ -255,7 +262,6 @@ export async function decryptMessageObject(message: Message, seenIds = new Set<s
               }
           } catch (e) {}
       }
-      // ------------------------------------------
 
       decryptedMsg.content = plainText;
 
@@ -270,7 +276,7 @@ export async function decryptMessageObject(message: Message, seenIds = new Set<s
             decryptedMsg.fileSize = metadata.size;
             decryptedMsg.fileType = metadata.mimeType;
             decryptedMsg.content = null; 
-            decryptedMsg.isBlindAttachment = true; // Flag as raw key
+            decryptedMsg.isBlindAttachment = true; 
           }
         } catch (e) { }
       }
@@ -279,13 +285,12 @@ export async function decryptMessageObject(message: Message, seenIds = new Set<s
       decryptedMsg.content = result.reason || 'waiting_for_key';
     } else {
       console.warn(`[Decrypt] Failed for msg ${decryptedMsg.id}:`, result?.error);
-      decryptedMsg.content = 'waiting_for_key'; // Retryable state
+      decryptedMsg.content = 'waiting_for_key'; 
       decryptedMsg.type = 'SYSTEM'; 
     }
 
     // 6. Dekripsi Replied Message
     if (decryptedMsg.repliedTo) {
-        // Recursively decrypt replied message, but don't skip retries necessarily or propagate depth
         decryptedMsg.repliedTo = await decryptMessageObject(decryptedMsg.repliedTo, seenIds, depth + 1, options);
     }
 
@@ -420,7 +425,6 @@ export const useMessageStore = createWithEqualityFn<State & Actions>((set, get)
       const { user } = useAuthStore.getState();
       if (!user) return;
 
-      // Optimistic Update
       const timestamp = Date.now();
       const tempReactionId = `temp_react_${timestamp}`;
       const optimisticReaction = {
@@ -434,14 +438,12 @@ export const useMessageStore = createWithEqualityFn<State & Actions>((set, get)
       };
       get().addLocalReaction(conversationId, messageId, optimisticReaction);
 
-      // Send as Message
       const metadata = {
           type: 'reaction',
           targetMessageId: messageId,
           emoji
       };
       
-      // Use timestamp as tempId to correlate socket response
       await get().sendMessage(conversationId, {
           content: JSON.stringify(metadata)
       }, timestamp);
@@ -476,11 +478,8 @@ export const useMessageStore = createWithEqualityFn<State & Actions>((set, get)
     }
 
     const actualTempId = tempId !== undefined ? tempId : Date.now();
-    
-    // Use helper to detect reaction
     const isReactionPayload = !!parseReaction(data.content);
 
-    // Create optimistic message ONLY if it is NOT a reaction
     if (!isReactionPayload) {
         const optimisticMessage: Message = {
             ...data,
@@ -494,7 +493,6 @@ export const useMessageStore = createWithEqualityFn<State & Actions>((set, get)
             reactions: [],
             statuses: [{ userId: user.id, status: 'READ', messageId: `temp_${actualTempId}`, id: `temp_status_${actualTempId}`, updatedAt: new Date().toISOString() }],
             status: 'SENDING', 
-            // [FIX] Include full repliedTo object for optimistic UI
             repliedTo: data.repliedTo,
         };
 
@@ -518,26 +516,16 @@ export const useMessageStore = createWithEqualityFn<State & Actions>((set, get)
       let ciphertext = '';
       let x3dhHeader: any = null;
 
-      // LAZY SESSION INITIALIZATION (X3DH) - SINGLE SOURCE OF TRUTH
-      // No more getPendingHeader check here.
       if (!isGroup && data.content) {
           const state = await retrieveRatchetStateSecurely(conversationId);
-          
           if (!state) {
-             // Fix: Use p.id instead of p.userId
              const peerId = conversation.participants.find(p => p.id !== user.id)?.id;
-             
              if (peerId) {
-                 // 1. Fetch Bundle
                  const theirBundle = await authFetch<any>(`/api/keys/prekey-bundle/${peerId}`);
-                 
-                 // 2. Establish Session
                  const myKeyPair = await getMyEncryptionKeyPair();
                  const { sessionKey, ephemeralPublicKey, otpkId } = await establishSessionFromPreKeyBundle(myKeyPair, theirBundle);
-                 
                  const sodium = await getSodium();
                  
-                 // [DOUBLE RATCHET INIT ALICE]
                  const { worker_dr_init_alice } = await import('@lib/crypto-worker-proxy');
                  const newState = await worker_dr_init_alice({
                      sk: sessionKey,
@@ -546,16 +534,15 @@ export const useMessageStore = createWithEqualityFn<State & Actions>((set, get)
                  
                  await storeRatchetStateSecurely(conversationId, newState);
 
-                 // 4. Prepare Header for Peer
                  x3dhHeader = {
                      ik: sodium.to_base64(myKeyPair.publicKey, sodium.base64_variants.URLSAFE_NO_PADDING),
                      ek: ephemeralPublicKey,
                      otpkId: otpkId
                  };
              } else {
-                 console.error(`[X3DH] Peer not found in participants for ${conversationId}. Participants:`, conversation.participants);
+                 console.error(`[X3DH] Peer not found in participants for ${conversationId}.`);
                  toast.error("Encryption failed: Cannot identify recipient.");
-                 return; // STOP HERE
+                 return;
              }
           }
       }
@@ -564,7 +551,6 @@ export const useMessageStore = createWithEqualityFn<State & Actions>((set, get)
       let contentToEncrypt = data.content;
 
       if (contentToEncrypt) {
-        // --- INJEKSI PROFILE KEY ---
         try {
             const profileKey = await import('@lib/keychainDb').then(m => m.getProfileKey(user.id));
             if (profileKey) {
@@ -583,22 +569,17 @@ export const useMessageStore = createWithEqualityFn<State & Actions>((set, get)
         } catch (e) {
             console.error("Failed to inject profile key", e);
         }
-        // ---------------------------
 
-        // Encrypt content (gunakan contentToEncrypt)
         const result = await encryptMessage(contentToEncrypt, conversationId, isGroup, undefined, `temp_${actualTempId}`);
         ciphertext = result.ciphertext;
         
-        // [FIX] Capture MK immediately before it's gone
         if (!isGroup && result.mk) {
              mkToStore = result.mk;
-             // Store temporarily with tempId
              await import('@utils/crypto').then(({ storeMessageKeySecurely }) => 
                  storeMessageKeySecurely(`temp_${actualTempId}`, mkToStore!)
              );
         }
         
-        // Combine DR Header with Ciphertext (JSON payload) for private chats
         if (!isGroup && result.drHeader) {
             ciphertext = JSON.stringify({
                 dr: result.drHeader,
@@ -607,11 +588,10 @@ export const useMessageStore = createWithEqualityFn<State & Actions>((set, get)
         }
       }
       
-      // EMBED HEADER IF NEW SESSION
       if (x3dhHeader) {
           const payloadJson = JSON.stringify({
               x3dh: x3dhHeader,
-              ciphertext: ciphertext // This is already the {dr, ciphertext} JSON string if !isGroup
+              ciphertext: ciphertext 
           });
           ciphertext = payloadJson;
       }
@@ -619,7 +599,7 @@ export const useMessageStore = createWithEqualityFn<State & Actions>((set, get)
       const payload = {
           ...data,
           content: ciphertext,
-          sessionId: isGroup ? 'group_session' : undefined, // Placeholder for legacy compatibility if needed
+          sessionId: undefined, // [PHASE 3 FIX] No session ID needed for group anymore, or managed by logic
           fileKey: undefined, fileName: undefined, fileType: undefined, fileSize: undefined
       };
 
@@ -627,7 +607,6 @@ export const useMessageStore = createWithEqualityFn<State & Actions>((set, get)
       const isConnected = socket?.connected;
 
       if (!isConnected && !isReactionPayload) {
-        // [CRITICAL FIX] Use PAYLOAD (Encrypted), NOT data (Plaintext)
         const queueMsg = { ...payload, id: `temp_${actualTempId}`, tempId: actualTempId, conversationId, senderId: user.id, createdAt: new Date().toISOString() } as Message;
         await addToQueue(conversationId, queueMsg, actualTempId);
         return;
@@ -638,14 +617,12 @@ export const useMessageStore = createWithEqualityFn<State & Actions>((set, get)
             if (!isReactionPayload) {
                 get().replaceOptimisticMessage(conversationId, actualTempId, { ...res.msg, status: 'SENT' });
             } else {
-                // [FIX] Replace Optimistic Reaction ID
-                // contentToEncrypt is the original plaintext JSON string of the reaction
                 const reactionData = parseReaction(contentToEncrypt);
                 if (reactionData) {
                     const tempReactionId = `temp_react_${actualTempId}`;
                     get().replaceOptimisticReaction(conversationId, reactionData.targetMessageId, tempReactionId, {
                         ...reactionData,
-                        id: res.msg.id, // REAL ID FROM SERVER
+                        id: res.msg.id, 
                         userId: user.id,
                         createdAt: res.msg.createdAt,
                         user: user,
@@ -654,15 +631,12 @@ export const useMessageStore = createWithEqualityFn<State & Actions>((set, get)
                 }
             }
               
-            // LINK MESSAGE KEY FROM TEMP ID TO PERMANENT ID
             const msgId = res.msg.id;
-            // We don't need to pass the raw key again, just tell store to copy/move if needed.
-            // But since we can't move keys easily in IDB without reading, we read from temp and write to real.
             import('@utils/crypto').then(async ({ retrieveMessageKeySecurely, storeMessageKeySecurely, deleteMessageKeySecurely }) => {
                 const mk = await retrieveMessageKeySecurely(`temp_${actualTempId}`);
                 if (mk) {
                     await storeMessageKeySecurely(msgId, mk);
-                    await deleteMessageKeySecurely(`temp_${actualTempId}`); // Clean up temp key
+                    await deleteMessageKeySecurely(`temp_${actualTempId}`);
                 }
             }).catch(console.error);
               
@@ -670,7 +644,6 @@ export const useMessageStore = createWithEqualityFn<State & Actions>((set, get)
             if (!isReactionPayload) {
                 get().updateMessage(conversationId, `temp_${actualTempId}`, { error: true, status: 'FAILED' });
             } else {
-                // TODO: Handle failed reaction UI feedback
                 toast.error("Failed to send reaction");
             }
         }
@@ -695,14 +668,12 @@ export const useMessageStore = createWithEqualityFn<State & Actions>((set, get)
       const { tempId, conversationId, data, attempt } = item;
       
       if (attempt > 5) {
-        // Give up after 5 retries
         console.warn(`[Queue] Dropping message ${tempId} after too many retries.`);
         await removeFromQueue(tempId);
         get().updateMessage(conversationId, `temp_${tempId}`, { error: true, status: 'FAILED' });
         continue;
       }
 
-      // Update UI to show we are trying again
       get().updateMessage(conversationId, `temp_${tempId}`, { status: 'SENDING', error: false });
 
       socket.emit("message:send", data, async (res: { ok: boolean, msg?: Message, error?: string }) => {
@@ -712,12 +683,9 @@ export const useMessageStore = createWithEqualityFn<State & Actions>((set, get)
         } else {
           console.error(`[Queue] Failed to send queued message ${tempId}:`, res.error);
           await updateQueueAttempt(tempId, attempt + 1);
-          // Keep it in queue, but maybe mark visual error if needed?
-          // For now, let it stay 'SENDING' or maybe 'FAILED' until next retry
         }
       });
 
-      // Small delay to prevent flooding
       await new Promise(r => setTimeout(r, 200)); 
     }
   },
@@ -742,7 +710,6 @@ export const useMessageStore = createWithEqualityFn<State & Actions>((set, get)
     const uploadId = addActivity(activity);
     const tempId = Date.now();
     
-    // 1. Create optimistic message
     const optimisticMessage: Message = {
       id: `temp_${tempId}`,
       tempId: tempId,
@@ -756,7 +723,7 @@ export const useMessageStore = createWithEqualityFn<State & Actions>((set, get)
       fileName: file.name,
       fileSize: file.size,
       fileType: file.type,
-      fileUrl: URL.createObjectURL(file) // Use local blob URL for instant preview
+      fileUrl: URL.createObjectURL(file) 
     };
     get().addOptimisticMessage(conversationId, optimisticMessage);
     useConversationStore.getState().updateConversationLastMessage(conversationId, optimisticMessage);
@@ -764,40 +731,30 @@ export const useMessageStore = createWithEqualityFn<State & Actions>((set, get)
     try {
       updateActivity(uploadId, { progress: 5 });
 
-      // 2. Encrypt file content and get the key
       const { encryptedBlob, key: fileKey } = await encryptFile(file);
       
-      // 3. Encrypt the file key (using conversation session)
-      // ...
-      
       updateActivity(uploadId, { progress: 20 });
 
-      // 4. Get Presigned URL
       const presignedRes = await api<{ uploadUrl: string, publicUrl: string, key: string }>('/api/uploads/presigned', {
           method: 'POST',
           body: JSON.stringify({
-              fileName: file.name, // Keep original name for extension/key generation
-              fileType: 'application/octet-stream', // [FIX] Use generic binary type for encrypted content
-              // Ideally we upload encrypted blob, so mime might be application/octet-stream
-              // But R2 validation checks extension.
-              // Let's keep original fileType for presigned request so server validation passes,
-              // but upload the encrypted blob.
+              fileName: file.name, 
+              fileType: 'application/octet-stream', 
               folder: 'attachments',
-              fileSize: encryptedBlob.size // [FIX] Use actual encrypted size (includes IV/Tag overhead)
+              fileSize: encryptedBlob.size 
           })
       });
 
       updateActivity(uploadId, { progress: 30 });
 
-      // 5. Upload to R2 (PUT)
       await new Promise<void>((resolve, reject) => {
           const xhr = new XMLHttpRequest();
           xhr.open('PUT', presignedRes.uploadUrl, true);
-          xhr.setRequestHeader('Content-Type', 'application/octet-stream'); // [FIX] Match presigned request
+          xhr.setRequestHeader('Content-Type', 'application/octet-stream'); 
           
           xhr.upload.onprogress = (e) => {
               if (e.lengthComputable) {
-                  const percentComplete = (e.loaded / e.total) * 60; // Max 60% of total progress bar (30+60=90)
+                  const percentComplete = (e.loaded / e.total) * 60; 
                   updateActivity(uploadId, { progress: 30 + percentComplete });
               }
           };
@@ -813,20 +770,17 @@ export const useMessageStore = createWithEqualityFn<State & Actions>((set, get)
 
       updateActivity(uploadId, { progress: 95 });
 
-      // 6. Create Metadata Payload
       const metadata = {
           type: 'file',
           url: presignedRes.publicUrl,
-          key: fileKey, // Plain key, will be encrypted by sendMessage
+          key: fileKey, 
           name: file.name,
           size: file.size,
           mimeType: file.type
       };
 
-      // 7. Send as Message
       await get().sendMessage(conversationId, {
           content: JSON.stringify(metadata),
-          // Store these for optimistic local use (but sendMessage will override content with ciphertext)
           fileName: file.name,
           fileType: file.type
       }, tempId);
@@ -838,7 +792,6 @@ export const useMessageStore = createWithEqualityFn<State & Actions>((set, get)
       removeActivity(uploadId);
       console.error("File upload failed:", error);
       toast.error(`Failed to upload ${file.name}.`);
-      // Mark optimistic message as failed
       set(state => ({
         messages: {
           ...state.messages,
@@ -854,14 +807,7 @@ export const useMessageStore = createWithEqualityFn<State & Actions>((set, get)
 
     if (hasRestoredKeys) {
       try {
-        // Find the conversation first to determine its type
         const conversation = useConversationStore.getState().conversations.find(c => c.id === id);
-        // Key distribution logic is now handled by sendMessage, but we still need to handle the 1-on-1 case.
-        // [PRIVACY FIX] Disable server-side ratchet on load. 
-        // We want to force Client-Side X3DH (Lazy Init) in sendMessage for the first message.
-        // if (conversation && !conversation.isGroup) {
-        //   await ensureAndRatchetSession(id);
-        // }
       } catch (sessionError) {
         console.error("Failed to establish session, decryption may fail:", sessionError);
       }
@@ -922,7 +868,6 @@ export const useMessageStore = createWithEqualityFn<State & Actions>((set, get)
   addOptimisticMessage: (conversationId, message) => {
     set(state => {
       const currentMessages = state.messages[conversationId] || [];
-      // Prevent duplicates based on ID or tempId
       if (currentMessages.some(m => m.id === message.id || (m.tempId && message.tempId && m.tempId === message.tempId))) {
         return state;
       }
@@ -934,15 +879,9 @@ export const useMessageStore = createWithEqualityFn<State & Actions>((set, get)
       const currentUser = useAuthStore.getState().user;
       let decrypted = message;
 
-      // [FIX] Self-Echo Handling:
-      // If message is from ME, and I have an optimistic version, 
-      // DON'T decrypt (I don't have the private key for my own X3DH header).
-      // Use the local content instead.
       if (currentUser && message.senderId === currentUser.id && message.tempId) {
-          // [FIX] Loose comparison for tempId (String vs Number issue)
           const optimistic = get().messages[conversationId]?.find(m => m.tempId && String(m.tempId) === String(message.tempId));
           if (optimistic) {
-              // Copy content/file data from optimistic message
               decrypted = {
                   ...message,
                   content: optimistic.content,
@@ -951,21 +890,17 @@ export const useMessageStore = createWithEqualityFn<State & Actions>((set, get)
                   fileName: optimistic.fileName,
                   fileSize: optimistic.fileSize,
                   fileType: optimistic.fileType,
-                  // Keep server metadata
                   id: message.id,
                   createdAt: message.createdAt,
                   statuses: message.statuses
               };
           } else {
-              // Fallback: Try decrypt (might fail if X3DH)
               decrypted = await decryptMessageObject(message);
           }
       } else {
-          // Normal inbound message
           decrypted = await decryptMessageObject(message);
       }
       
-      // Check if reaction
       const reactionPayload = parseReaction(decrypted.content);
       
       if (reactionPayload) {
@@ -979,7 +914,6 @@ export const useMessageStore = createWithEqualityFn<State & Actions>((set, get)
               isMessage: true
           };
           
-          // CRITICAL FIX: Only replace optimistic reaction if WE are the sender
           if (message.tempId && currentUser && message.senderId === currentUser.id) {
               const optimisticId = `temp_react_${message.tempId}`;
               get().replaceOptimisticReaction(conversationId, reaction.messageId, optimisticId, reaction);
@@ -987,7 +921,6 @@ export const useMessageStore = createWithEqualityFn<State & Actions>((set, get)
               get().addLocalReaction(conversationId, reaction.messageId, reaction);
           }
       } else {
-          // FIX: If this is our own message with a tempId, replace the optimistic one
           if (message.tempId && currentUser && message.senderId === currentUser.id) {
               get().replaceOptimisticMessage(conversationId, message.tempId, decrypted);
           } else {
@@ -1003,9 +936,6 @@ export const useMessageStore = createWithEqualityFn<State & Actions>((set, get)
   },
 
   replaceOptimisticMessage: (conversationId, tempId, newMessage) => set(state => {
-    // [FIX] Don't revoke Blob URL yet, as we might copy it to the new message for smooth transition.
-    // Let browser GC handle it on navigation/refresh.
-    
     return {
       messages: { ...state.messages, [conversationId]: (state.messages[conversationId] || []).map(m => (m.tempId && String(m.tempId) === String(tempId)) ? { ...m, ...newMessage, tempId: undefined, optimistic: false } : m) }
     };
@@ -1013,15 +943,12 @@ export const useMessageStore = createWithEqualityFn<State & Actions>((set, get)
   removeMessage: (conversationId, messageId) => set(state => {
     const messages = state.messages[conversationId] || [];
     
-    // 1. Remove from main list (if it's a regular message)
     const messageToRemove = messages.find(m => m.id === messageId);
     if (messageToRemove?.fileUrl?.startsWith('blob:')) {
       URL.revokeObjectURL(messageToRemove.fileUrl);
     }
     const filteredMessages = messages.filter(m => m.id !== messageId);
 
-    // 2. Remove from nested reactions (if it's a reaction message)
-    // This handles the "Reaction as Message" deletion sync
     const updatedMessages = filteredMessages.map(m => {
         if (m.reactions && m.reactions.some(r => r.id === messageId)) {
             return {
@@ -1047,7 +974,6 @@ export const useMessageStore = createWithEqualityFn<State & Actions>((set, get)
       [conversationId]: (state.messages[conversationId] || []).map(m => {
         if (m.id === messageId) {
           const newReactions = [...(m.reactions || [])];
-          // Prevent duplicates
           if (!newReactions.some(r => r.id === reaction.id)) {
             newReactions.push(reaction);
           }
@@ -1108,18 +1034,15 @@ export const useMessageStore = createWithEqualityFn<State & Actions>((set, get)
     set(state => ({
       messages: { ...state.messages, [conversationId]: state.messages[conversationId]?.filter(m => m.tempId !== tempId) || [] },
     }));
-    // Use the original content from the 'preview' field for the retry and preserve the original tempId
     get().sendMessage(conversationId, { content: preview, fileUrl, fileName, fileType, fileSize, repliedToId }, tempId);
   },
 
-  // Resend all pending messages (for sync after reconnect)
   resendPendingMessages: () => {
     const state = get();
     Object.entries(state.messages).forEach(([conversationId, messages]) => {
       messages
-        .filter(m => m.optimistic && !m.error) // Only optimistic messages that haven't failed yet
+        .filter(m => m.optimistic && !m.error)
         .forEach(m => {
-          // Retry sending the message
           get().retrySendMessage(m);
         });
     });
@@ -1132,7 +1055,6 @@ export const useMessageStore = createWithEqualityFn<State & Actions>((set, get)
   },
 
   reDecryptPendingMessages: async (conversationId: string) => {
-    // Add a small delay to ensure IndexedDB consistency after key storage
     await new Promise(r => setTimeout(r, 1000));
 
     const state = get();
@@ -1149,16 +1071,13 @@ export const useMessageStore = createWithEqualityFn<State & Actions>((set, get)
 
     const reDecryptedMessages = await Promise.all(
       pendingMessages.map(async (msg) => {
-          // Pass the message object directly. decryptMessageObject will handle ciphertext priority.
           return await decryptMessageObject(msg);
       })
     );
 
     const messageMap = new Map(conversationMessages.map(m => [m.id, m]));
     reDecryptedMessages.forEach(m => {
-        // Only update if we actually managed to decrypt it or status changed
         if (m.content !== 'waiting_for_key' && m.content !== '[Requesting key to decrypt...]') {
-             // Process potential reactions that were stuck in pending state
              const payload = parseReaction(m.content);
              if (payload) {
                  get().addLocalReaction(conversationId, payload.targetMessageId, {
@@ -1170,13 +1089,11 @@ export const useMessageStore = createWithEqualityFn<State & Actions>((set, get)
                      user: m.sender,
                      isMessage: true
                  });
-                 // Don't add reaction message to the list (filter it out)
                  messageMap.delete(m.id);
                  return;
              }
              messageMap.set(m.id, m);
         } else {
-             // Still pending, keep it in map
              messageMap.set(m.id, m);
         }
     });
@@ -1211,4 +1128,4 @@ export const useMessageStore = createWithEqualityFn<State & Actions>((set, get)
       };
     });
   },
-}));
\ No newline at end of file
+}));
diff --git a/web/src/workers/crypto.worker.ts b/web/src/workers/crypto.worker.ts
index 63eae7f7..907ba940 100644
--- a/web/src/workers/crypto.worker.ts
+++ b/web/src/workers/crypto.worker.ts
@@ -1186,7 +1186,8 @@ self.onmessage = async (event: MessageEvent) => {
            state: { CK: bytesToB64(newCK), N: currentN + 1 },
            header,
            ciphertext: combined,
-           signature: sodium.to_base64(signature, sodium.base64_variants.URLSAFE_NO_PADDING)
+           signature: sodium.to_base64(signature, sodium.base64_variants.URLSAFE_NO_PADDING),
+           mk: Array.from(mk) // Return MK so sender can store it for history
         };
 
         sodium.memzero(CKBytes);
