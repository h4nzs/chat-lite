// Datasource & Generator
generator client {
  provider = "prisma-client-js"
  previewFeatures = ["fullTextSearch", "postgresqlExtensions"]
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
  extensions = [pg_trgm]
}

model User {
  id                 String    @id @default(cuid())
  email              String    @unique
  username           String    @unique
  passwordHash       String
  name               String
  avatarUrl          String?
  description        String?
  publicKey          String?   // Encryption/Identity Key
  signingKey         String?   // Verification Key
  showEmailToOthers  Boolean   @default(false)
  hasCompletedOnboarding Boolean @default(false)
  isEmailVerified Boolean  @default(false) // Tambahkan ini
  createdAt          DateTime  @default(now())
  updatedAt          DateTime  @updatedAt
  role               String    @default("USER") // Bisa diisi "ADMIN" buat akun lu doang
  bannedAt           DateTime? // Kalau ada isinya, berarti dia dibanned
  banReason          String?   // Catatan buat nampilin pesan ke user pas login gagal

  messages             Message[]
  participants         Participant[]
  messageStatuses      MessageStatus[]
  refreshTokens        RefreshToken[]
  // reactions removed
  pushSubscriptions    PushSubscription[]
  hiddenConversations  UserHiddenConversation[]
  createdConversations Conversation[]           @relation("CreatedConversations")
  authenticators       Authenticator[]
  currentChallenge     String?
  encryptedPrivateKey  String?    @db.Text

  // Relation to the simplified pre-key bundle
  preKeyBundle         PreKeyBundle?
  sessionKeys          SessionKey[]

  // Relasi Blocking
  blockedUsers BlockedUser[] @relation("Blocker") // User ini memblokir siapa aja
  blockedBy    BlockedUser[] @relation("Blocked") // User ini diblokir sama siapa aja

  @@index([createdAt])
}

// Simplified PreKeyBundle model
model PreKeyBundle {
  id          Int      @id @default(autoincrement())
  identityKey String   // User's long-term public identity key
  key         String   // The public part of the signed pre-key
  signature   String   // Signature of the 'key'
  
  user        User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  userId      String   @unique
}


model Conversation {
  id            String         @id @default(cuid())
  isGroup       Boolean        @default(false)
  title         String?
  description   String?
  avatarUrl     String?
  creatorId     String?
  creator       User?          @relation("CreatedConversations", fields: [creatorId], references: [id], onDelete: SetNull, onUpdate: Cascade)
  lastMessageAt DateTime?      @db.Timestamptz(6)
  createdAt     DateTime       @default(now())
  updatedAt     DateTime       @updatedAt
  participants  Participant[]
  messages      Message[]
  hiddenBy      UserHiddenConversation[]

  @@index([lastMessageAt(sort: Desc)])
  @@index([createdAt])
  @@index([isGroup])
}

model Participant {
  id             String       @id @default(cuid())
  user           User         @relation(fields: [userId], references: [id], onDelete: Cascade)
  userId         String
  conversation   Conversation @relation(fields: [conversationId], references: [id], onDelete: Cascade)
  conversationId String
  joinedAt       DateTime     @default(now())
  lastReadMsgId  String?
  role           String       @default("MEMBER")
  isPinned       Boolean      @default(false)

  @@unique([userId, conversationId])
  @@index([conversationId])
  @@index([userId])
  @@index([joinedAt])
  @@index([lastReadMsgId])
}


model Message {
  id                  String          @id @default(cuid())
  conversation        Conversation    @relation(fields: [conversationId], references: [id], onDelete: Cascade)
  conversationId      String
  sender              User            @relation(fields: [senderId], references: [id], onDelete: Cascade)
  senderId            String
  content             String?      @db.Text
  // File metadata removed (Blind Attachments)
  // Reactions removed (Reactions as Messages)
  
  sessionId           String?
  encryptedSessionKey String?
  createdAt           DateTime        @default(now())
  statuses            MessageStatus[]
  linkPreview         Json?
  expiresAt           DateTime?

  repliedToId         String?         @map("replied_to_id")
  repliedTo           Message?        @relation("Replies", fields: [repliedToId], references: [id], onDelete: SetNull, onUpdate: NoAction)
  replies             Message[]       @relation("Replies")

  @@index([conversationId, createdAt(sort: Desc)])
  @@index([senderId])
  @@index([sessionId])
  @@index([createdAt])
  @@index([repliedToId])
  @@index([content(ops: raw("gin_trgm_ops"))], type: Gin)
}


enum DeliveryStatus {
  SENT
  DELIVERED
  READ
}


model MessageStatus {
  id        String          @id @default(cuid())
  message   Message         @relation(fields: [messageId], references: [id], onDelete: Cascade)
  messageId String
  user      User            @relation(fields: [userId], references: [id], onDelete: Cascade)
  userId    String
  status    DeliveryStatus  @default(SENT)
  updatedAt DateTime        @updatedAt

  @@unique([messageId, userId])
  @@index([userId, status])
  @@index([messageId])
  @@index([status])
  @@index([updatedAt])
}

// MessageReaction model removed

model RefreshToken {
  id           String   @id @default(cuid())
  jti          String   @unique
  user         User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  userId       String
  userAgent    String?
  ipAddress    String?
  revokedAt    DateTime?
  replacedById String?
  createdAt    DateTime @default(now())
  lastUsedAt   DateTime @updatedAt
  expiresAt    DateTime

  @@index([userId])
  @@index([expiresAt])
  @@index([jti])
  @@index([revokedAt])
}


model SessionKey {
  id                    String   @id @default(cuid())
  conversationId        String
  sessionId             String
  userId                String
  user                  User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  isInitiator           Boolean  @default(false)
  encryptedKey          String
  initiatorEphemeralKey String?  // For the recipient to derive the initial shared secret
  createdAt             DateTime @default(now())
  expiresAt             DateTime?

  @@index([conversationId, userId, sessionId])
}

model PushSubscription {
  id        String   @id @default(cuid())
  endpoint  String   @unique
  p256dh    String
  auth      String
  userId    String
  createdAt DateTime @default(now())

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)
}

model UserHiddenConversation {
  id             String       @id @default(cuid())
  userId         String
  conversationId String
  user           User         @relation(fields: [userId], references: [id], onDelete: Cascade)
  conversation   Conversation @relation(fields: [conversationId], references: [id], onDelete: Cascade)

  @@unique([userId, conversationId])
}

model Authenticator {
  id              String  @id
  credentialID    String  @unique
  userId          String
  user            User    @relation(fields: [userId], references: [id], onDelete: Cascade)
  credentialPublicKey String
  counter         BigInt
  credentialDeviceType String
  credentialBackedUp   Boolean
  transports      String?

  @@index([userId])
}

// Model untuk menyimpan informasi blocking antar pengguna
model BlockedUser {
  id        String   @id @default(cuid())
  blockerId String
  blockedId String
  createdAt DateTime @default(now())

  blocker   User @relation("Blocker", fields: [blockerId], references: [id], onDelete: Cascade)
  blocked   User @relation("Blocked", fields: [blockedId], references: [id], onDelete: Cascade)

  @@unique([blockerId, blockedId]) // Mencegah duplikasi (blokir orang yang sama 2x)
  @@index([blockerId])
  @@index([blockedId])
}
